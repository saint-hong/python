# 파이썬 기초 정리
- 데이터 사이언스 스쿨의 김도형 박사님의 파이썬 기초 부분을 공부하고 정리하였습니다.

# 계산기로 사용하기

### 정수 연산

```python
1 + 1

=====<print>=====
2
```

### 파이썬 띄어쓰기 규칙
- 코드의 처음과 마지막에는 빈칸을 넣지 않는다.
- 빈칸은 항상 하나만 넣는다.
- 숫자나 연산기호 사이는 한 칸을 띄운다.
- 괄호를 연 직후나 닫기 직전에는 빈칸을 넣지 않는다.

```python
# 모두 붙여쓰지 않는다.

1+1

# 너무 많이 띄우지 않는다. 한 칸만 띄운다.

1  +  1
```

### 연산기호
- + : +
- - : -
- x : *
- 나누기 (몫) : //
- 나누기 (소수점까지 나누기) : /
- 나누기 (나머지) : %
- 제곱 : **

```python
# 덧셈과 뺄셈

2 + 4 - 5

=====<print>=====
1
```
```python
# 곱하기
```
```python
# 나누기 : 몫을 반환한다.

8 // 4

=====<print>=====
2
```
```python
# 나누기 : 나머지값을 반환한다.

11 % 4

=====<print>=====
3
```
```python
# 나누기 : 소수점까지 반환한다.

10 / 4

=====<print>=====
2.5
```
```python
# 음수 제곱은 역수이다. 2^(-1) = 1/2

2 ** -1

=====<print>=====
0.5
```
```python
3 * 2 - 8 // 4

=====<print>=====
4
```
### 연산 순서와 괄호
- 파이썬도 일반 수학의 연산을 따른다. 곱셈과 나눗셈을 덧셈이나 뺄셈보다 먼저 시행한다.
- 소괄호, 중괄호, 대괄호를 구분하지 않고 모두 소괄호 기호를 사용하여 나타낸다.

```python
100 / (3 * (10 - (3 * 2)) + 8)

=====<print>=====
5.0
```
```python
48320 - ((365 - 5 * 9) / 16) * 987

=====<print>=====
28580.0
```
```python
((3 ** 4 - 3 * 7) % 5 + 4) ** 2

=====<print>=====
16
```

### 부등식의 참과 거짓 계산
- 참과 거짓을 계산하는 부등식 연산
- 참 : True, 거짓 : False
- 연산을 할 때는 등호기호가 2번 반복된다.
    - 크다 : >
    - 작다 : <
    - 같다 : ==
    - 같지 않다 : !=
    - 같거나 크다 : >=
    - 같거나 작다 : <=

```python
2 > 1

=====<print>=====
True

2 > 2

=====<print>=====
False

2 == 2

=====<print>=====
True

2 != 1

=====<print>=====
True

3 <= 3

=====<print>=====
True

2 + 1 == 3

=====<print>=====
True
```

### 부울리언 대수
- 참과 거짓에 대해서 부울리언 대수 Boolean algebra 연산을 할 수 있다.
    - & (and) : 연산은 두 값이 모두 참일때만 답이 참이 된다. **즉 하나라도 거짓이면 답은 거짓이다.**
    - | (or) : 연산은 두 값이 모두 거짓일 때만 답이 거짓이 된다. **즉 하나라도 참이면 답은 참이다.**

```python
True & True

=====<print>=====
True

True & False

======<print>=====
False

False & True 

=====<print>=====
False

False & False

=====<print>=====
False

True | True

=====<print>=====
True

True | False

=====<print>=====
True

False | True

=====<print>=====
True

False | False

=====<print>=====
False

(2 != 1) | (3 >= 4)

=====<print>=====
True

(5 <= 6) & ((0 == 0) | (3 < 4))

=====<print>=====
True
```

### 변수 사용하기
- 어떤 값을 계속 사용할 때는 그 값을 변수 variable에 담아두었다가 사용할 수 있다.
- 변수에 값을 넣는 것을 할당 assignment한다고 말한다.
- 변수에 값을 할당할 때는 등호기호를 사용하고 좌변에는 할당할 변수 이름, 우변에는 할당할 값을 입력한다.
    - 변수이름 = 변수값
- 변수이름 : 알파벳으로 시작, 다음에 숫자 가능, 변수의 이름에서 대문자와 소문자는 구분해서 사용
    - apple != Apple != APPLE 모두 서로 다른 변수이다.

```print
x = 5
(2 * x - 1) ** 2 + 1

=====<print>=====
82

y = 3
z = 2

(x ** (2 * y)) * (z + 10)

=====<print>=====

187500

j = 8
k = 10
i = 0.5

((j == 0) & (0 < k)) | (i <= 100)

=====<print>=====
True
```

# 부동소수점 실수 자료형

### 정수와 실수 자료형
- 파이썬에서는 정수 integer뿐 아니라 소숫점을 포함하는 실수 real number도 다룰 수 있다.
- 정수 데이터에는 수숫점이 없고 실수 데이터엔느 소수점이 붙어 있다.
- 데이터의 자료형 type에 따라서 컴퓨터 메모리에 저장되는 방식이 다르다.
- 정수와 실수도 저장되는 방식이 다르다.
    - 정수는 int라는 정수 자료형으로 처리된다.
    - 실수는 float이라는 부동소수점 (floating point number) 자료형으로 처리된다.
- type 명령으로 데이터의 타입을 알 수 있다.

```python
# 정수 integer

10

# 실수 real number

10.0

# 정수부가 0인 경우는 생략가능

.1
```

- 숫자 계산시 소숫점이 있는 실수가 사용되면 결과는 실수가 된다.
- 나눗셈의 결과는 입력에 상관없이 항상 실수로 처리한다.

```python
# 정수 integer

10 * 5

=====<print>=====
50

# 실수 real number

10.0 * 5

=====<print>=====
50.0

# 실수 real number

10 / 5

=====<print>=====
2.0
```

- 자료형 확인 

```python
type(10)

=====<print>=====
int

type(10.0)

=====<print>=====
float
```

### 부동소수점 실수
- 프로그래밍 언어는 **IEEE 754**라는 국제표준에 따라서 실수를 부동소수점 방식으로 표현한다.
- 부동소수점 방식에서는 숫자를 **정수로 된 유효숫자와 정수로 된 지수의 곱**으로 표현한다.
    - 십진수 부동소수점 방식 : 123.456은 123456 * 10^-3이므로 123456이라는 정수 유효숫자와 -3이라는 정수의 지수로 나타낸다.
- 파이썬에서는 **유효숫자e지수** 라는 방법으로 부동소수점 형태를 직접 표현한다.
    - **유효숫자e지수 = 유효숫자 * 10^지수**

```python
# 123e2 = 123.0 * 100 = 12300.0

123e2

=====<print>=====
12300.0

# 123e-2 = 123.0 * 0.01 = 1.23

123e-2

=====<print>=====
1.23

# 123.456e-3 = 123.456 * 10^-3 = 0.123456

123.456e-3

=====<print>=====
0.123456

# 5e8 = 5.0 * 10^8 = 500000000.0

5e8

=====<print>=====
500000000.0

# 5.6e3 = 5.6 * 10^3 = 5600.0

5.6e3

=====<print>====
5600.0

# -2.1e2 = -2.1 * 10^2 = -210.0

-2.1e2

=====<print>=====
-210.0

# -3.4e-1 = -3.4 * 10^(-1) = -0.34

-3.4e-1

=====<print>=====
-0.34

# 3.141592

3141592e-6

=====<print>=====
3.141592

# 2.718

2718e-3

=====<print>=====
2.718

# 1.4

14e-1

=====<print>=====
1.4
```

### 십진법과 이진법
- 컴퓨터는 십진법이 아닌 이진법을 사용한다.
- 십진법에서는 0, 1, 2, 3, 4, 5, 6, 7, 8, 9의 10개 숫자만 사용하고, 10이상의 숫자는 10, 100, 1000, 10000,... 자리를 숫자로 나열하여 표현한다.
- 모든 십진법 숫자는 10의 제곱의 합으로 풀어서 나타낼 수 있다.
    - 12 = 10 + 2 = 1 * 10^1 + 2 * 10^0
    - 123 = 100 + 20 + 3 = 10^2 + 2 * 10^1 + 3 * 10^0
- 소수점이 있는 경우에는 소수점 아래의 숫자가 10^-1, 10^-2, 10^-3,... 자리를 나타내는 숫자이다.
    - 1.2 = 1 + 0.2 = 1 * 10^0 + 2 * 10^-1
    - 1.123 = 1 + 0.1 + 0.02 + 0.003 = 1 * 10^1 + 2 * 10^-2 + 3 * 10^-3
- 이진법은 0, 1의 2개의 숫자만 사용한다.
- 2 이상의 수는 2, 4, 8, 16,... 자리를 나타내는 숫자를 나열하여 표현한다.
    - 1 = 1 * 2^0 = 1(2)
    - 2 = 1 * 2^1 + 0 * 2^0 = 10(2)
    - 3 = 1 * 2^1 + 1 * 2^0 = 11(2)
    - 4 = 1 * 2^2 + 0 * 2^1 + 0 * 2^0 = 100(2)
    - 5 = 1 * 2^2 + 0 * 2^1 + 1 * 2^0 = 101(2)
    - 15 = 1 * 2^3 + 1 * 2^2 + 1 * 2^1 + 1 * 2^0 = 1111(2)

- 십진법으로 나타내기

```python
# 1234
# 1000 + 200 + 30 + 4

(1 * 10 ** 3) + (2 * 10 ** 2) + (3 * 10**1) + (4 * 10**0)

=====<print>=====
1234

# 1010
# 1000 + 10

(1 * 10 ** 3) + (1 * 10 ** 1)

=====<print>=====
1010

# 3.14
# 3 + 0.1 + 0.04

(3 * 10 ** 0) + (1 * 10 ** -1) + (4 * 10 ** -2)

=====<print>=====
3.14

# 0.023
# 0.02 + 0.003

(2 * 10 ** -2) + (3 * 10 ** -3)

=====<print>=====
0.023
```

#### 십진수를 이진수로 변환
- bin() 명령어 사용

```python
bin(3)

=====<print>=====
'0b11'

bin(23948)

=====<print>=====
'0b101110110001100'
```

#### 소수점이 있는 경우 이진법으로 나타내기

```python
# 0.5 = 1 * 2 ^-1 = 0.1(2)

1 * 2 ** -1

=====<print>=====
0.5

# 0.25 = 0 * 2^-1 + 1 * 2^-2 = 0.01(2)

(0 * 2 ** -1) + (1 * 2 ** -2)

=====<print>=====
0.25

# 0.125 = 0 * 2^-1 + 0 * 2^-2 + 1 * 2^-3 = 0.001(2)

(0 * 2 ** -1) + (0 * 2 ** -2) + (1 * 2 ** -3)

=====<print>=====
0.125

# 0.75 = 1 * 2^-1 + 1 * 2^-2 = 0.11(2)

(1 * 2 ** -1) + (1 * 2 ** -2)

=====<print>=====
0.75

# 0.375 = 0 * 2^-1 + 1 * 2^-2 + 1 * 2^-3 = 0.011(2)

(0 * 2 ** -1) + (1 * 2 ** -2) + (1 * 2 ** -3)

=====<print>=====
0.375

# 129 = 1 * 2^7 + 0 * 2^6 + 0 * 2^5 + 0 * 2^4 + 0 * 2^3 + 0 * 2^2 + 0 * 2^1 + 1 * 2^0
# 10000001

(1 * 2 ** 7) + (0 * 2 ** 6) + (0 * 2 ** 5) + (0 * 2 ** 4) + (0 * 2 ** 3) + (0 * 2 ** 2) + (0 * 2 ** 1) + (1 * 2 ** 0)

=====<print>=====
129
```

### 부동소수점 오차
- 1보다 작은 수의 경우에는 십진법으로 간단히 표현되는 수도 이진법에서는 무한개의 유효숫자를 가질 수 있다.
    - 0.1을 이진법으로 나타내면 0.0011001100110011... 0011(2)가 무한히 반복된다.
- **컴퓨터에서는 하나의 숫자를 나타내기 위한 메모리 크기가 제한되어있다.**
- 특정 소수점 이하는 생략하고 가장 비슷한 숫자로 보여준다.
- 파이썬 콘솔이나 주피터 노트북에서는 0.1은 0.1로 출력된다.
    - REPL 인터페이스에서는 값을 출력할 때 편의상 일정 소수점 이하를 생략하기 때문.
- 소수점 55자리까지 출력가능
    - %precision 55 입력하고 0.1 출력하면 소수점 55 자리까지 출력된다.
    - %precision %r 원래데로 돌아간다.

```python
0.1

=====<print>=====
0.1

# 부동소수점의 출력 길이를 바꿀 수 있다.
# 소수점 이하 55자리까지 출력

%precision 55

=====<print>=====
'%.55f'

0.1

=====<print>=====
0.1000000000000000055511151231257827021181583404541015625

# 부동소수점의 출력 길이를 원래데로 되돌리는 명령어

%precision %r

=====<print>=====
0.1
```

#### 컴퓨터에서의 실수 계산
- 소수점 아래 자리의 계산으로 인해 연산의 결과가 다를 수 있다.
    - 0.1 + 0.2 의 값과 0.3의 정확한 표현은 다르다.
- 따라서 실수끼리 비교할 떄는 round()를 사용하여 유효숫자를 지정한 반올림을 한후 비교한다.

```python
# 0.1과 0.2의 합은 정확하게 0.3이 아니다. 부동소수점 이하의 연산이 반영되기 때문이다.
0.1 + 0.2 == 0.3

=====<print>=====
False

0.1 + 0.2

=====<print>=====
0.30000000000000004

# 소수점 출력 길이를 더 늘려서 확인

%precision 55
0.3

=====<print>=====
0.2999999999999999888977697537484345957636833190917968750
```

#### 부동소수점의 영향없이 계산하는 방법
- round() 함수 사용
```python
# 부동소수점 이하 5자리까지만 연산

round(0.1 + 0.2, 5) == round(0.3, 5)

=====<print>=====
True
```

### 자료형 변환
- 실수를 정수로 변환 : int()
    - 정확한 정수로 표현할 수 없을 경우 소수점 이하의 자리는 버린다.
- 정수를 실수로 변환 : float()

```python
# 실수를 정수로 변환

int(1.0)

# 정수를 실수로 변환

float(1)

# 음수인 실수를 정수로 변환하면 음수는 그대로이다.
int(-3.9)

=====<print>=====
-3
```

### NaN과 Inf
- IEEE 754 표준에 따라서 부동소수점 자료형은 특별한 두 가지 값을 표현할 수 있다.
    - NaN : Not a Number : **숫자가 아닌 것**
    - Inf : Infinity : **무한대**

```print
float("NaN")

=====<print>=====
nan

float("Inf")

=====<print>=====
inf

float("-inf")

=====<print>=====
-inf

float("nan")

=====<print>=====
nan
```

# 파이썬으로 글자 출력하기
- 프로그래밍 언어에서는 글자를 문자열 (string) 이라고 부른다.
- 파이썬에서 문자열을 만들때는 따옴표를 사용한다.
    - 큰 따옴표나 작은 따옴표 둘 다 사용가능
- 문자열 출력 명령어 : **print()**

```python
print("Hello!")

=====<print>====
Hello!
```

### 문자열 연산
- 문자열도 숫자 처럼 덧셈과 곱셈 연산을 할 수 있다.
- 덧셈은 두 문자열을 붙이고, 곱셈 연산은 문자열을 반복한다.

```python
print("내 이름은 " + "홍길동" + "입니다.")

=====<print>=====
내 이름은 홍길동입니다.

print("*" * 10)

=====<print>=====
**********
```

### 숫자를 문자열로 바꾸기
- 숫자를 문자열과 더하려면 숫자를 **str()** 명령을 써서 문자열 자료형으로 바꿔준다.

```python
n = 10
print("별표를 " + str(n) + "번 출력합니다.")
print("*" * n)

=====<print>=====
별표를 10번 출력합니다.
**********
```

### 한 줄 띄우기
- print() 명령어는 한 번 호출할 때마다 한 줄씩 출력한다.
- print() 안에 다음 줄 넘기기 기호 **"\n"**을 사용하면 여러줄을 출력할 수 있다.

```python
print("한 줄 쓰고 \n그 다음 줄을 씁니다.")

=====<print>=====
한 줄 쓰고
그 다음 줄을 씁니다.
```

### 줄을 바꾸지 않고 이어서 출력하기
- print()를 여러번 사용하면서 문자열을 한 줄에 출력하기 위해서 **end=""** 인수를 사용한다.

```python
print("한 줄 쓰고,", end=" ")
print("이어서 쓴다.")

=====<print>=====
한 줄 쓰고, 이어서 쓴다.
```

### 문자열 값을 가지는 변수
- 변수에 문자열을 저장할 수 있다.

```python
mark = "$"
n = 20
print(mark + " 기호를 " + str(n) + "번 출력합니다.")
print(mark * n)

=====<print>=====
$ 기호를 20번 출력합니다.
$$$$$$$$$$$$$$$$$$$$
```

### 따옴표 출력하기
- 파이썬에서 두 가지 따옴표를 사용하는 이유는 문자열이 따옴표를 포함하는 경우가 있기 때문이다.
- 큰 따옴표로 둘러싸인 문자열을 출력할 때는 작은 따옴표를 사용한다.
    - 두가지 따옴표를 이중으로 사용할 때는 서로 반대의 것을 사용하면 된다.
    - '  " "  '
    - "  '  ' "

```python
# 문장에서 ""를 사용하기

print('둘리가 "호이!" 라고 말했다.')

# 문장에서 ''를 사용하기

print("둘리가 '이제 어디로 가지?'하고 생각했다.")
```

### 여러 줄의 문자열 출력하기
- 여러 줄의 문자열을 출력하거나 변수에 할당, 큰 따옴표나 작은 따옴표를 3번 반복한다.
    - """ 여러줄의 문자열 """
    - ''' 여러줄의 문자열 '''

```python
multi_line_string = """
파이썬(영어 : python)은 1991년 프로그래머인 귀도 반 로섬(Guido van Rossum)이 발표한 고급 프로그래밍 언어로, 플랫폼 독립적이며 인터프리터식, 객체지향적, 동적 타이핑(dynamically typed) 대화형 언어이다. 파이썬이라는 이름은 귀도가 좋아하는 코미디 <Monty Python's Flying Circus>에서 따온 것이다."""

print(multi_line_string)

=====<print>=====
파이썬(영어 : python)은 1991년 프로그래머인 귀도 반 로섬(Guido van Rossum)이 발표한 고급 프로그래밍 언어로, 플랫폼 독립적이며 인터프리터식, 객체지향적, 동적 타이핑(dynamically typed) 대화형 언어이다. 파이썬이라는 이름은 귀도가 좋아하는 코미디 <Monty Python's Flying Circus>에서 따온 것이다.
```
```python
# 줄바꾸기 "\n"

print("Simple is better than complex. \nComplex is better than complicated.")

=====<print>=====
Simple is better than complex.
Complex is better than complicated.
```

- 줄바꾸기를 사용하여 출력하기

```python
golbange = "@"
n = 6

print(golbange * n + "\n" + golbange + "    " + golbange + \
      "\n" + golbange + "    " + golbange + \
      "\n" + golbange + "    " + golbange + \
      "\n" + golbange * n)

=====<print>=====
@@@@@@
@    @
@    @
@    @
@@@@@@
```

### 문자열 치환
- 문자열에서 특정 문자를 다른 문자로 바꾸려면 **replace** 메서드를 사용한다.
    - 문자열에서 공백을 없앨 수도 있다. " " -> ""

```python
"2020.10.23".replace(".", "-")

=====<print>=====
'2020-10-23'

# 공백을 공백없음으로 치환
"world with space".replace(" ", "")

=====<print>=====
'worldwithspace'

# 대문자를 소문자로 치환
"lowercase A".replace("A", "a")

=====<print>=====
'lowercase a'
```

# 파이썬의 문자열 형식화
- 문자열 형식화 string formatting : 복잡한 문자열을 출력하기 위한 방법
    - **%** 기호 또는 **format** 메서드, **f** 문자열을 사용한다.

### % 기호를 사용한 문자열 형식화
- "문자열" % 값 : 문자열 부분에 값이 들어간다.
- 문자열의 어느 위치에 들어가는지 표시하기 위해 **형식지정 문자열(format specification string)** 을 붙인다.
    - **%s** : 문자열
    - **%d** : 정수
    - **%f** : 부동소수점 실수    

```python
"내 이름은 %s입니다." % "홍길동"

=====<print>=====
'내 이름은 홍길동입니다.'

"나는 %d살 입니다." % 12

=====<print>=====
'나는 12살 입니다.'

# %f는 실수형 데이터를 출력해준다
"원주율의 값은 %f입니다." % 3.141592

=====<print>=====
'원주율의 값은 3.141592입니다.'

# %s 문자열과 %d 숫자를 함께 출려
"%s의 %s 과목의 점수는 %d이다." % ("철수", "영어", 90)

=====<print>=====
'철수의 영어 과목의 점수는 90이다.'

# 변수를 사용하여 문자열 형식화 기호 출력하기
name = "Tom"
age = 13

"%s is %d years old." % (name, age)

=====<print>=====
'Tom is 13 years old.'
```

### 고급 형식지정 문자열
- 형식지정 문자열은 여러가지 숫자 인수를 가질 수도 있다.
    - **%5s** : 문자열이 공백의 뒤로 오게하고, 문자열의 길이 + 공백의 길이=5가 되도록 한다.
    - **%-5d** : 숫자가 공백의 앞에 오게하고, 숫자의 길이 + 공백의 길이=5가 되록 한다.
    - **%.5f** : 소수점 아래 5자리까지 출력해준다.

```python
"[%20s]" % "*"

=====<print>=====
'[                   *]'

"[%-20s]" % "*"

=====<print>=====
'[*                   ]'

"[%20d]" % 1234

=====<print>=====
'[                1234]'

"[%-20d]" % 1234

=====<print>=====
'[1234                ]'
```

- 소수점 아래까지 출력 : %.소수점자리수f

```python
x = 1 / 3.0
"%.5f" % x

=====<print>====
'0.33333'
```

### 연습문제
- 형식지정 문자열을 사용하여 출력하기

```python
a = 3
b = 12

print("```")
print("%8s" % a)
print("x%7s" % b)
print("-" * 8)
print("%8s" % (a*b))
print("```")

=====<print>=====
       3
x     12
--------
      36
```
```python
# float을 str으로 바꾼 후 출력

a = 123456
b = 7890

print("```")
print("%10s" % (str(a / 1000).replace(".", ",")))
print("+%8s" % (str(b / 1000).replace(".", ",")) + "0")
print("-" * 10)
print("%10s" % (str((a+b) / 1000).replace(".", ",")))
print("```")

=====<print>=====
   123,456
+    7,890
----------
   131,346
```
```python
# 형식지정 문자열을 두번 사용하여 출력

a = 123456
b = 7890

print("```")
print("%10s" % ("%.3f" % (a / 1000)).replace(".", ","))
print("+%9s" % ("%.3f" % (b / 1000)).replace(".", ","))
print("-" * 10)
print("%10s" % ("%.3f" % ((a+b) / 1000)).replace(".", ","))
print("```")

=====<print>=====
   123,456
+    7,890
----------
   131,346
```

- 부동소수점의 기호 .을 ,로 치환

```python
str((a+b) / 1000).replace(".", ",")

=====<print>=====
'131,346'
```

### format 매서드를 사용한 문자열 형식화
- %기호와 달리 자료형을 사용할 필요없이 {} 기호를 사용한다.
- 문자열안에서 {}를 출력하려면 이중으로 감싸준다. {{}}
- {}의 순서를 지정하도록 숫자를 넣을 수 있다.
    - {0}, {1}, {2}
    - 여러번 출력할 수도 있다.
- 숫자대신 인수의 이름을 지정할 수 있다.
    - "{a}".format(a=10)
- 숫자 없이 순서대로 입력하면 순서대로 출력된다.
- **format 방식에서 고급 형식지정 문자열을 사용할 수 있다.**
    - {:>10} : 전체 10칸 차지, 공백을 앞에, 문자열을 뒤에 (>)
    - {:<10} : 전체 10칸 차지, 공백을 뒤에, 문자열을 앞에 (<)
    - {:^10} : 전체 10칸 차지, 문자열 앞뒤에 공백 (^)
    - {:.5f} : 부동소수점의 소수점 아래 5자리까지 표시
    - {:,} : 천단위 쉼표 표시
    - {:*>10} : 전체 10칸 차지, 빈칸에 *을 넣는다. 문자열을 뒤에 (>)
    - {:*<10} : 전체 10칸 차지, 빈칸에 *을 넣는다. 문자열을 앞에 (<)
    - {:*^10} : 전체 10칸 차지, 빈칸에 *을 넣는다. 문자열을 가운데 (^)
- **format 방식은 {} 안에서 값의 리스트나 사전의 인덱싱을 할 수 있다.**

```python
"내 이름은 {}입니다.".format("홍길동")

=====<print>=====
'내 이름은 홍길동입니다.'

# 문장내에서 {} 사용
"내 이름은 {{{}}}입니다.".format("홍길동")

=====<print>=====
'내 이름은 {홍길동}입니다.'

# 여러개의 문자열을 나타낼 때는 순서를 지정해 줄 수 있다.
"{2}의 {0} 점수는 {1}점 입니다.".format("수학", 90, "철수")

=====<print>=====
'철수의 수학 점수는 90점 입니다.'

# 변수를 사용하여 해당 변수에 해당하는 값을 넣을 수 있다.
"{a} 점수 : {x} 점, {b} 점수 : {y}".format(a="영어", b="수학", x=90, y=80)

=====<print>=====
'영어 점수 : 90 점, 수학 점수 : 80'
```

#### format과 형식지정 문자열을 사용하여 문자열 출력하기
- {형식}.format 

```python
# 전체공백 10, 문자를 뒤에, 공백을 앞에
"[{:>10}]".format("*")

=====<print>=====
'[         *]'

# 전체공백 10, 문자를 앞에, 공백을 뒤에
"[{:<10}]".format("&")

=====<print>=====
'[&         ]'

# 전체공백 20, 문자를 가운데, 공백을 양옆에
"[{:^20}]".format("*")

=====<print>=====
'[         *          ]'
```

- 다른 문자열 사이에 사용할 수 있다.

```python
"[abc{:^3}defgh]".format("&")

=====<print>=====
'[abc & defgh]'
```

- 실수형 자료의 출력

```python
"[{:20.5f}]".format(1 / 3)

=====<print>=====

```

- 기호를 사용하면 문자중간에 기호를 넣어준다.

```python
"[{:20,}]".format(1234567890)

=====<print>=====
'[       1,234,567,890]'
```

- 공백에 다른 기호를 넣을 수 있다.

```python
"[{:->20}]".format("*")

=====<print>=====
'[-------------------*]'

"[{:-<20}]".format("*")

=====<print>=====
'[*-------------------]'

=====<print>=====
'[---------*----------]'
```

- format 방식의 문자열 출력도 인덱싱을 할 수 있다.
- {[인덱스번호]}
```python
x = [10, 11, 12]

"리스트의 첫번째 원소 = {[0]}".format(x)

=====<print>=====
'리스트의 첫번째 원소 = 10'

# 딕셔너리 자료형 사용
y = {"a" : 10, "b" : 11, "c" : 12}

"사전의 a키 값 = {0[a]}".format(y)

=====<print>=====
'사전의 a키 값 = 10'
```

### 연습문제
- format 매서드의 문자열 형식화 기호를 사용하여 출력하기

```python
a = 123456
b = 7890

print("---")
print("{:>10,}".format(a))
print("+{:>9,}".format(b))
print("-" * 10)
print("{:>10,}".format(a + b))
print("---")

=====<print>=====
---
   123,456
+    7,890
----------
   131,346
---
```

# 조건문

### if ~ else 명령
```
if 참 또는 거짓을 가지는 값 :
    조건이 참일 때 실행되는 명령들
else :
    조건이 거짓일 때 실행되는 명령들
```

- 조건 condition : 참 또는 조건을 가지는 값
- 들여쓰기 indentation : 실행되는 명령들은 빈칸을 4칸 띄우고 쓴다.

```python
# 홀수, 짝수를 구분해주는 코드, 2로 나눈 나머지가 0인지 아닌지를 조건문으로 사용
a = 1

if a % 2 == 0 :
    print("짝수")
else :
    print("홀수")

=====<print>=====
홀수
```
```python
# 특정 구간에 해당하는 경우 홀수인지 짝수인지 구분하는 코드
b = 55

if (b >= 10) & (b < 100) & (b % 2 == 0) :
    print("2자리 수의 짝수이다.")
else :
    print("2차리 수의 짝수가 아니다.")

=====<print>=====
2차리 수의 짝수가 아니다.
```

### 연습문제
- 윤년 찾기
- 변수 y의 값이 윤년이면 "윤년입니다"를 출력하고 아니면 "윤년이 아닙니다"라고 출력하는 프로그램을 만든다.
- 서력 기원 연수가 4로 나누어 떨어지는 해는 윤년이다 : 2004, 2008, 2012, 2016...
- 이 중에서 100으로 나누어 떨어지는 해는 평년이다 : 1900, 2100, 2200...
- 이 중에서 400으로 나누어 떨어지는 해는 윤년이다 : 1600, 2000, 2400...

```python
def solve(y) :
    if y % 4 == 0 :
        if y % 100 == 0 :
            if y % 400 == 0 :
                print("윤년 입니다.")
            else :
                print("윤년이 아닙니다.")
        else :
            print("윤년 입니다.")
    else :
        print("윤년이 아닙니다.")	
```
- 400으로 나누어 떨어지는 해

```
solve(400)

====<print>=====
윤년 입니다.
```

- 4로 나누어 떨어지지 않는 해
```python
solve(1997)

=====<print>=====
윤년이 아닙니다.
```

- 4의 배수이면서 100으로 나누어 떨어지는 해
```python
solve(1900)

=====<print>=====
윤년이 아닙니다.
```

- 조건문에서 논리연산기호를 사용하여 수정한 코드
- 조금더 간결해졌다.
```python
def solve_2(y) :
    if (y % 4 == 0) & (y % 400 == 0) :
        print("윤년입니다.")
    else :
        if (y % 100 == 0) :
            print("윤년이 아닙니다.")
        elif (y % 4 == 0) :
            print("윤년입니다.")
        else :
            print("윤년이 아닙니다.")
```

```python
solve(321)

=====<print>=====
윤년이 아닙니다.
```

```python
solve_2(2024)

=====<print>=====
윤년입니다.
```

### if ~ elif ~ else 명령
- 조건으로 나누어야 할 경우의 수가 두가지가 아니라 여러가지인 경우

```
if 조건1 :
    조건1이 참일 때 실행되는 명령
elif 조건2 :
    조건1이 거짓이고 조건2가 참일 때 실행되는 명령
elif 조건3 :
    조건1과 조건2가 거짓이고 조건3이 참일 때 실행되는 명령
else :
    모든 조건도 참이 아니면 실행되는 명령
```
```python
# 10문제 중 8개 이상 맞히면 A, 8개미만 5개이상 맞히면 B, 5개 미만을 맞히면 C

c = 6

if c >= 8 :
    print("A")
elif c >= 5 :
    print("B")
else :
    print("C")

=====<print>=====
B
```

### 연습문제
- 어떤 농장에서는 수박이 10kg이 넘으면 1등급, 7kg이 넘으면 2등급, 그렇지 않고 4kg이 넘으면 3등급, 나머지는 4등급을 준다. 
- 수박의 등급을 정하는 파이썬 코드를 작성하시오.

```python
wm = 7

if wm > 10 :
    print("1등급")
elif wm > 7 :
    print("2등급")
elif wm > 4 :
    print("3등급")
else :
    print("4등급")

=====<print>=====
3등급
```

### 중첩조건문
- 중첩 nesting : 조건문 안에 조건문이 포함된 형태

```
if 조건1 :
    조건1이 참일 때 실행되는 명령
    if 조건2 :
        조건1과 조건2가 모두 참일 때 실행되는 명령
    else :
        조건1은 참이고 조건2는 거짓일 때 실행되는 명령
else :
    조건1이 거짓일 때 실행되는 명령
```

```python
# 남자는 10번 이상을 해야 합격 pass 아니면 불합격 fail
# 여자는 5번 이상을 해야 합격이라면 다음과 같이 프로그램을 만들 수 있다.

sex = "boy"
pushup = 8

if sex == "boy" :
    if pushup >= 10 :
        grade = "Pass"
    else :
        grade = "Fail"
else :
    if pushup >= 5 :
        grade = "Pass"
    else :
        grade = "Fail"

print(grade)

=====<print>=====
Fail
```

### 연습문제
- 죄수의 딜레마 게임이론
- A가 자백하면 B는 10년 징역, 반대로 B가 자백하면 A는 징역 10년
- A와 B가 둘다 자백하면, 둘다 징역 5년
- A와 B가 둘다 자백하지 않으면, 둘다 징역 1년
- XA, XB = True or False
- YA, YB = 징역연수

```python
def solve(XA, XB, YA=0, YB=0) :
    if XA == True :
        if XB == True :
            YA = YB = 5
        else :
            YB = 10
    else :
        if XB == True :
            YA = 10
        else :
            YA = YB = 1

    print("YA : {}".format(YA)," ", "YB : {}".format(YB))
```
```python
# A와 B 둘다 자백하면 둘다 5년 징역
solve(True, True, 0, 0)

=====<p>=====

YA : 5   YB : 5

# B만 자백하면 A 징역 10년
solve(False, True, 0, 0)

=====<p>=====
YA : 10   YB : 0

# A만 자백하면 B 징역 10년
solve(True, False, 0, 0)

=====<p>=====
YA : 0   YB : 10

# A와 B 둘다 자백하지 않으면 둘다 징역 1년
solve(False, False, 0, 0)

=====<p>=====
YA : 1   YB : 1
```

# 파이썬 함수
- 함수 function : 입력을 받아 그 입력에 해당하는 출력을 반환(return)하는 기계
    - f(500) = "생수", f(1000) = "콜라"
- **def** 키워드와 **return** 키워드로 함수를 만들 수 있다.

```
def 함수이름(입력변수이름) :
    출력변수를 만드는 명령

    return 출력변수이름
```
- 숫자 x를 입력하면 두 배가 되도록 하는 함수

```python
def twotimes(x) :
    y = x * 2
    return y

# 함수 호출
twotimes(10)

=====<p>=====
20
```

### 연습문제
- 짝수가 입력되면 짝수라는 문자열을, 홀수가 입력되면 홀수라는 문자열을 반환하는 함수를 만들어라

```python
def odd_even(x) :
    if x % 2 == 0 :
        result = "짝수"
    else :
        result = "홀수"
    return result


#함수 호출
odd_even(20)

=====<p>=====
'짝수'

odd_even(15)

=====<p>=====
'홀수'
```

- 윤년인 년도가 입력되면 윤년이라는 문자열을, 그렇지 않은 연도가 입력되면 평년이라는 문자열을 반환하는 함수를 만들어라.

```python
def leap_year(y) :
    if (y % 4 == 0) & (y % 400 == 0) :
        result = "윤년"
    else :
        if (y % 100 == 0) :
            result = "평년"
        elif (y % 4 == 0) :
            result = "윤년"
        else :
            result = "평년"

    return result

# 함수 호출
leap_year(400)

=====<p>=====
'윤년'

leap_year(1995)

=====<p>=====
'평년'
```
- 평년일 때 1,3, 5, 7, 8, 10, 12월은 31일, 4, 6, 9, 11월은 30일, 2월은 28일이다. 월을 나타내는 숫자를 입력하면 그 달의 날짜수를 반환하는 함수 days1를 만든다.
   - days1(11) = 30   

```python
def days1(m) :
    if m in [1, 3, 5, 7, 8, 10, 12] :
        days = 31
    elif m in [2] :
        days = 28
    elif m in [4, 6, 9, 11] :
        days = 30

    return days

# 함수 호출
days1(11)

=====<p>=====
30

days1(12)

=====<p>=====
31
```
### 입력이 여러 개인 함수
- 함수의 입력은 한 개가 아니라 여러 개가 되어도 상관없다. 
- 입력 변수가 여러개이면 쉼표, 영어로 comma 를 사용하여 함수를 정의할 수 있다.
- 입력 변수는 원하는 만큼 얼마든지 만들 수 있다.

```
def 함수이름(입력변수1, 입력변수2, 입력변수3) :
    출력변수를 만드는 명령
    
    return 출력변수이름
```
```python
def add(x, y) :
    return x + y

# 함수 호출
add(1, 2)

=====<p>=====
3
```
```python
def sum(a, b, c) :
    s = a + b + c

    return s

#함수 호출
sum(10, 20, 30)

=====<p>=====
60
```

### 연습문제
- 연도를 나타내는 숫자와 월을 나타내는 숫자를 입력하여 그 달의 날짜 수를 반환하는 함수 days2를 만든다.
   - days2(2015, 1) = 31
- 2월달의 경우 윤년 또는 평년에 따라서 월수가 달라지므로 입력받은 연도를 먼저 윤년인지 아닌지 확인한다.
- 조건문을 만들어 윤년, 평년을 확인 한후 윤년은 29일, 평년은 28일을 반환한다.

```python
# 윤년, 평년 확인하는 함수
def leap_year(y) :
    if (y % 4 == 0) & (y % 400 == 0) :
        result = "윤년"
    else :
        if (y % 100 == 0) :
            result = "평년"
        elif (y % 4 == 0) :
            result = "윤년"
        else :
            result = "평년"

    return result
```

- 달의 날짜를 반환하는 함수
  - 함수안에서 윤년, 평년 확인하는 함수를 실행한다.

```python
# days2 함수안에서 leap_year 함수를 호출하여 윤년인지 아닌지를 확인한다.

def days2(y, m) :
    if m in [1, 3, 5, 7, 8, 10, 12] :
        days = 31
    elif m == 2 :
        if leap_year(y) == "윤년" :
            days = 29
        else :
            days = 28
    elif m in [4, 6, 9, 11] :
        days = 30

    return days
```
```python
#함수 호출
days2(2015, 1)

=====<p>=====
31

# 윤년인 해의 2월
days2(2012, 2)

=====<p>=====
29

# 평년인 해의 2월
days2(2022, 2)

=====<p>=====
28
```

### 람다 함수
- 람다 함수 lambda function : 함수에 이름을 주지 않거나 코드를 짧게 줄여서 쓰는 방법
- **함수 자체를 다른 함수의 인수로 넣을 때, 함수의 출력값을 함수로 받을 때 유용하게 사용된다.**

```python
# 입력받은 수의 2배를 반환하는 람다함수
ff = lambda x : 2 * x

# 람다 객체 실행
ff(2)

=====<p>=====
4
```

### 지역변수
- 지역변수 local variable : 함수안에서 만들어지고 사용되는 함수
- 함수에 넣은 입력변수나 함수 안에서 만들어지는 변수는 함수 바깥에서는 사용할 수 없다.
- 이름이 같은 변수라고 하더라도 별개의 변수와 같다.

```python
# 함수 안에서 y 지역변수를 정의 한 후 변수를 확인해 본다.
def f(x) :
    y = 10 * x
    print("y = ", y)
    return y

#함수 호출
f(10)

=====<p>=====
y =  100
100
```
- 함수안에서 y라는 변수를 만들었지만 함수 바깥에서는 y가 정의 되지 않았다.
   - 에러가 뜬다.
```python
y

=====<p>=====
---------------------------------------------------------------------------
NameError                                 Traceback (most recent call last)
C:\Users\Public\Documents\ESTsoft\CreatorTemp/ipykernel_12400/3563912222.py in <module>
----> 1 y

NameError: name 'y' is not defined
```

- 함수 바깥에서 변수를 할당하고, 다시 함수안에서 변수를 할당해도 영향이 없다.

```python
y = 1000
y

=====<p>=====
1000

#함수 호출해서 지역변수 y를 확인해본 후 다시 전역변수를 확인한다.
f(1)

=====<p>=====
y =  10
10

#전역변수 y확인
y

=====<p>=====
1000
```

### 연습문제
- 3개의 숫자를 입력하면 숫자들의 합과 숫자들을 제곱한 숫자들의 합의 차이를 계산하는 함수 diffsum을 만든다.
- 큰 수에서 작은 수를 뺀 결과이므로 항상 0보다 크거나 같아야 한다.

```python
def diffsum(a, b, c) : 
    sum = a + b + c
    square_sum = a ** 2 + b ** 2 + c ** 2
    
    if square_sum > sum : 
        result = square_sum - sum
    else : 
        result = sum - square_sum
    
    return result

# 함수 호출
diffsum(5, 4, 2)

=====<p>=====
34

diffsum(2, 4, 1)

=====<p>=====
14
```

### 전역변수
- 전역변수 global variable : 함수 바깥에서 만들어진 변수를 함수안에서 사용할 수 있다.
- 지역변수는 함수 안에서 만들어진 변수로 함수 바깥에서는 사용할 수 없다.
- 전역변수와 같은 변수를 함수 안에서 만들면, 함수 바깥으로 나오면 지역변수는 사라지고 원래의 변숫값으로 돌아온다.
- 함수안에서 함수 바깥의 변수의 값을 바꿔야할 경우 **global** 키워드를 선언해준다.

```python
z = 3

def f2(x) :
    y = z * x
    print("y = ", y)
    print("z = ", z)

    return y

#함수 호출
f2(10)

=====<p>=====
y =  30
z =  3
30
```

#### 함수안에서 전역변수와 같은 변수를 만든경우
- 함수 바깥에서는 지역변수가 사라지고 전역변수 값이 할당되어 있다.
- 지역변수가 전역변수를 바꾸지 못한다.

```python
# 함수 바깥의 전역변수
z = 3

def f3(x) :
    # 함수 안의 지역변수
    z = 90
    y = z * x
    print("y = ", y)
    print("z = ", z)

    return y

#함수 호출 ; 지역변수에 값이 할당됨
f3(10)

=====<p>=====
y =  900
z =  90
900

# 전역변수 z의 값은 그대로이다.
z

=====<p>=====
3
```

#### global 키워드를 사용하면 지역변수로 전역변수 값을 바꿀 수 있다.

```python
z = 3

def f4(x) :
    global z

    z = 99
    y = z * x
    print("y = ", y)
    print("z = ", z)

    return y

#함수 호출, global 함수를 사용했기 때문에 지역변수 z에 값을 할당했지만 전역변수 z도 값이 바뀐다. 
f4(10)

=====<p>=====
y =  990
z =  99
990

#전역변수 z
z

=====<p>=====
99
```

### 연습문제
- 함수 바깥에 m이라는 전역 변수를 만들고 그 값을 0으로 할당한다.
- 앞에서 만든 diffsum 함수를 고쳐서 diffsum 함수와 같은 값을 반환
- 함수를 실행할 때마다 diffsum 함수에서 계산된 값이 원래 있던 m보다 크면 m을 계산된 값으로 바꾸는 함수 diffsum2를 만든다.

```python
m = 0

def diffsum2(a, b, c) :
    global m

    sum = a + b + c
    square_sum = a ** 2 + b ** 2 + c ** 2

    if square_sum > sum :
        result = square_sum - sum
    else :
        result = sum - square_sum

    if result > m :
        m = result
    else :
        m = m

    return result

# 함수 호출
diffsum2(1, 2, 3)

=====<p>=====
8

# 전역변수 m의 값이 0에서 8로 바뀜
m

=====<p>=====
8

diffsum2(0, 0, 1)

=====<p>=====
0

m

=====<p>=====
8

# 전역변수 m의 값 8보다 함수의 결과가 더 크므로, 전역변수 m을 이값으로 바꿔준다.
diffsum2(2, 4, 5)

=====<p>=====
34

m

=====<p>=====
34
```

# 파이썬 for 반복문

### for 반복문
- 명령이 반복될 수 있게 하는 반복문 (loop)

```
for 카운터변수 in range(반복횟수) :
    반복해서 실행할 명령
```

- 카운터 변수 counter variable : 현재 몇 번쨰 반복인지를 알려주는 변수
- 카운터 변수의 이름은 아무거나 사용할 수 있다. 
- 전문 프로그래머들은 i, j 변수 이름을 자주 사용한다. 
- 카운터 변수는 현재 실행 횟수에 해당하는 숫자가 들어가게 되는데, 처음 실행할 때는 아직 실행한 적이 없으므로 0이된다.
    - 1부터 출력하려면 카운터변수에 1을 더해주고, 시행횟수를 1을 줄이면 된다.

#### 카운터 변수에 1을 더해주어서 처음 시작을 1로 바꾼다.
- 반복횟수를 1을 줄인다.

```python
for i in range(10) :
    print("=" + str(i) + "=")

=====<p>=====
=0=
=1=
=2=
=3=
=4=
=5=
=6=
=7=
=8=
=9=
```
```python
for i in range(9) :
    print("=" + str(i + 1) + "=")

=====<p>=====
=1=
=2=
=3=
=4=
=5=
=6=
=7=
=8=
=9=
```

### 연습문제
- 반복문과 문자열 연산을 사용하여 다음과 같이 출력한다.
- * 기호를 1개씩 늘려가면서 출력하기

```python
for i in range(9) :
    print("*" * (i + 1))

=====<p>=====
*
**
***
****
*****
******
*******
********
*********

```

- * 기호를 1개씩 줄여가면서 출력하기

```python
for i in range(9, 0, -1) :
    print("*" * i)

=====<p>=====
*********
********
*******
******
*****
****
***
**
*
```
```python
array = np.arange(10)[::-1]

for i in array  :
    print("*" * (i+1))

=====<p>=====
**********
*********
********
*******
******
*****
****
***
**
*
```

- * 기호를 1행마다 1개씩 늘리다가, 1행마다 1개씩 줄여서 출력하기
- 10번째 행 이후부터 1개씩 줄이기 위해 10 - (현재 인덱스 % 10)의 규칙을 적용함
   - 10 - (11 % 10) = 9

```python
for i in range(20) :
    if i < 10 :
        print("*" * i)
    elif i >= 10 :
        print("*" * (10 - (i % 10)))

=====<p>=====
*
**
***
****
*****
******
*******
********
*********
**********
*********
********
*******
******
*****
****
***
**
*
```

- * 기호를 다이아몬드 형태로 출력하기

```python
"""
i가 11이후부터 홀수인 경우 다시 기호의 갯수가 x개 만큼 줄어든다.
i=13일 때 = 9개 (i - 4)
i=15일 떄 = 7개 (i - 8)
i=17일 떄 = 5개 (i - 12)
i=19일 때 = 3개 (i - 16)
i=21일 떄 = 1개 (i - 20)

이 규칙을 보면 11이후부터 i-x개라는 것을 알 수 있고, x는 4의 배수라는 것을 알 수 있다. i의 증가에 따라서 x도 증가하는 규칙이 필요한데, 11을 기준으로 다음 홀수와의 차이가 2의 배수라는 것을 찾을 수 있었다.
13 - 11 = 2
15 - 11 = 4
17 - 11 = 6
19 - 11 = 8
21 - 11 = 10

여기에 2배를 해주면 i의 증가에 따라서 4의 배수씩 증가하는 x를 구할 수 있다. 이 규칙을 식으로 정리하면 다음과 같다. 11이후 홀수인 i부터 22-i 개의 별을 출력해주면 된다.

i - ((i-11) * 2) = 22 - i
"""

for i in range(22) :
    if i <= 11 :
        if i % 2 != 0 :
            sign = "*" * i
            print(f"{sign:^11}")
    else :
        s_num = 11
        if i % 2 != 0 :
            sign = "*" * (s_num * 2 - i)
            print(f"{sign:^11}")

=====<p>=====
     *
    ***
   *****
  *******
 *********
***********
 *********
  *******
   *****
    ***
     *

```

### 중첩 for 반복문
- 중첩 반복문 nested loop : 반복문 안에 다시 반복문을 실행해야할 때 사용
- 카운터 변수가 겹치지 않아야 한다.

```python
for i in range(4) :
    for j in range(4) :
        print(i + j, end=" ")
    print()

=====<p>=====
0 1 2 3
1 2 3 4
2 3 4 5
3 4 5 6
```

- 주사위를 두 번 던져서 나오는 수의 쌍

```python
for i in range(6) :
    n1 = i + 1
    for j in range(6) :
        n2 = j + 1
        print(n1, n2)

=====<p>=====
1 1
1 2
1 3
1 4
1 5
1 6
2 1
2 2
2 3
2 4
2 5
2 6
3 1
3 2
3 3
3 4
3 5
3 6
...
```

- 주사위를 두번 던져서 나오는 수의 합이 4의 배수인 경우만 출력

```python
for i in range(6) :
    n1 = i + 1
    for j in range(6) :
        n2 = j + 1
        if (n1 + n2) % 4 == 0 :
            print(n1, n2, n1 + n2)

=====<p>=====
1 3 4
2 2 4
2 6 8
3 1 4
3 5 8
4 4 8
5 3 8
6 2 8
6 6 12
```

### 연습문제
- 어떤 주식의 가격은 매일 한 번 동전을 던져서 앞면이 나오면 전날 가격의 2배가 되고, 뒷면이 나오면 전날 가격의 절반이 된다.
- 1일에 주식의 가격이 1,024원이었을 때, 4일 주식의 가격이 나올 수 있는 모든 경우를 구한다.

```python
"""
주식의 가격 : x
  동전 앞면 : 0 : 2x
  동전 뒷면 : 1 : 1/2x

1일 주식 가격 : x = 1,024원
4일 주식 가격의 모든 경우는?
"""

x = 1024
stock = 0

for coin_1 in range(2) :
    if coin_1 == 0 :
        stock_2 = 2 * x
    else :
        stock_2 = 1/2 * x
    for coin_2 in range(2) :
        if coin_2 == 0 :
            stock_3 = 2 * stock_2
        else :
            stock_3 = 1/2 * stock_2
        for coin_3 in range(2) :
            if coin_3 == 0 :
                stock_4 = 2 * stock_3
            else :
                stock_4 = 1/2 * stock_3
            print("day2 coin {0} : stock {1}, day3 coin {2} : stock {3}, day4 coin {4} : stock {5}".format(coin_1, stock_2, coin_2, stock_3, coin_3, stock_4))

=====<p>=====
day2 coin 0 : stock 2048, day3 coin 0 : stock 4096, day4 coin 0 : stock 8192
day2 coin 0 : stock 2048, day3 coin 0 : stock 4096, day4 coin 1 : stock 2048.0
day2 coin 0 : stock 2048, day3 coin 1 : stock 1024.0, day4 coin 0 : stock 2048.0
day2 coin 0 : stock 2048, day3 coin 1 : stock 1024.0, day4 coin 1 : stock 512.0
day2 coin 1 : stock 512.0, day3 coin 0 : stock 1024.0, day4 coin 0 : stock 2048.0
day2 coin 1 : stock 512.0, day3 coin 0 : stock 1024.0, day4 coin 1 : stock 512.0
day2 coin 1 : stock 512.0, day3 coin 1 : stock 256.0, day4 coin 0 : stock 512.0
day2 coin 1 : stock 512.0, day3 coin 1 : stock 256.0, day4 coin 1 : stock 128.0
```

### 연습문제
- 프랑스의 수학자 페르마 Ferma 의 마지막 정리
- n이 2보다 큰 자연수인 경우에 a^n + b^n = c^n이 되는 자연수 a, b, c는 존재하지 않는다.
- n이 3이고 a, b, c가 1부터 10까지의 자연수일 때 페르마의 마지막 정리가 사실임을 중첩 반복문을 써서 보여라.
   - 중첩 반복문 3개 사용

```python
n = 3
counting = 0

for a in range(1, 11) :
    for b in range(1, 11) :
        for c in range(1, 11) :
            counting += 1
            if (a ** n) + (b ** n) == (c ** n) :
                print("Ferma False : {} + {} = {}, counting {}".\
                      format(a**n, b**n, c**n, counting))
            else :
                print("Ferma True : {} + {} != {}, counting {}".\
                      format(a**n, b**n, c**n, counting))

=====<p>=====
Ferma True : 1 + 1 != 1, counting 1
Ferma True : 1 + 1 != 8, counting 2
Ferma True : 1 + 1 != 27, counting 3
Ferma True : 1 + 1 != 64, counting 4
Ferma True : 1 + 1 != 125, counting 5
Ferma True : 1 + 1 != 216, counting 6
Ferma True : 1 + 1 != 343, counting 7
Ferma True : 1 + 1 != 512, counting 8
Ferma True : 1 + 1 != 729, counting 9
Ferma True : 1 + 1 != 1000, counting 10
...
```

### 카운터 변수가 변하는 경우
- 반복문에서 복잡한 형태는 안쪽 반복문의 횟수가 바깥쪽 반복문의 카운터 변수에 따라서 변하는 경우이다.

```python
"""
1부터 5까지 더하기
"""

n = 5
sum = 0

for i in range(n) :
    sum = sum + (i + 1)

print(sum)

=====<print>=====
15
```

```python
"""
1~1, 1~2, 1~3, ... 합을 구해야 한다면 카운터 변수를 연결시켜야 한다.

print() 함수의 위치에 따라서 안쪽 반복문의 마지막 결과만 출력된다.
"""

for j in range(10) :
    sum = 0
    for i in range(j + 1) :
        sum = sum + (i + 1)
    print("1~{}의 합 {}".format(i, sum))

=====<print>=====
1~0의 합 1
1~1의 합 3
1~2의 합 6
1~3의 합 10
1~4의 합 15
1~5의 합 21
1~6의 합 28
1~7의 합 36
1~8의 합 45
1~9의 합 55
```

### 연습문제
-다음과 같은 수열이 있을 때 n번째 수열의 값을 구하라.
```
1
1+(1+2)
1+(1+2)+(1+2+3)
1+(1+2)+(1+2+3)+(1+2+3+4)
...
1+(1+2)+(1+2+3)+(1+2+3+4)+...+(1+2+3+...+n)
```

```python
def solve(n) :
    sum_arr = []
    count = 0
    for i in range(1, n+1) :
        sum = 0
        count += 1
        for j in range(i+1) :
            sum = sum + j

        sum_arr.append(sum)

    print("{}째 수열의 합 {}".format(count, np.sum(sum_arr)))

=====<p>=====
1째 수열의 합 1
2째 수열의 합 4
3째 수열의 합 10
4째 수열의 합 20
5째 수열의 합 35
6째 수열의 합 56
7째 수열의 합 84
8째 수열의 합 120
9째 수열의 합 165
10째 수열의 합 220
11째 수열의 합 286
12째 수열의 합 364
13째 수열의 합 455
14째 수열의 합 560
15째 수열의 합 680
16째 수열의 합 816
17째 수열의 합 969
18째 수열의 합 1140
19째 수열의 합 1330
20째 수열의 합 1540
```

- 조금 다른 코드
```python
def solve2(n) : 
    final_sum = 0
    count = 0
    for i in range(1, n+1) : 
        sum = 0
        count += 1
        for j in range(i+1) : 
            sum = sum + j
            
        final_sum = final_sum + sum
    
    print("{}번째 수열의 합 {}".format(count, final_sum))

# 함수 호출
solve2(5)

=====<p>=====
5번째 수열의 합 35
```

# 여러 개의 자료를 한 변수에 담기
- 하나의 변수에 여러 개의 자료를 한꺼번에 저장하고 필요할 때 꺼내어 쓸 수 있다.
- 리스트 list : 여러개의 자료가 순서가 있을 때
- 딕셔너리 dictionary : 여러개의 자료가 이름이 있을 때

### 자료의 순서만 가지는 리스트 자료형
- 리스트 자료형에는 여러개의 자료를 순서데로 저장 할 수 있다.
```
리스트 변수 = [자료1, 자료2, 자료3]
```

```python
x = [88, 89, 90]
x

=====<p>=====
[88, 89, 90]
```

### 인덱싱
- 인덱싱 indexing : 리스트 자료형에서 특정한 자료를 꺼내기 위한 방법
- 변수이름 끝에 대괄호(barcket)를 붙이고, 그 안에 자료 순서를 뜻하는 숫자를 넣는다.
```
리스트변수[인덱스]
```
- 첫번째 자료는 인덱스가 1이 아니라 0이다.

```python
x[0]

=====<p>=====
88

x[1]

=====<p>=====
89

(x[0] + x[1]) / 2

=====<p>=====
88.5
```

### 연습문제
- 시험성적을 나타내는 리스트 자료형을 만들고 평균을 구하라

```python
scores = [10, 20, 30, 40, 50]
print(scores)
mean = (scores[0] + scores[1] + scores[2] + scores[3] + scores[4]) / 5
print(mean)

=====<p>=====
[10, 20, 30, 40, 50]
30.0
```

### 자료의 이름을 가지는 딕셔너리 자료형
- 딕셔너리 자료형에는 여러가지 자료를 이름을 붙여서 저장할 수 있다.
```
딕셔너리변수 = {자료이름1 : 자료값1, 자료이름2 : 자료값2, 자료이름3 : 자료값3}
```
- 자료 갯수는 얼마든지 상관없다.
- 자료이름 : key 키
- 자료값 : value 값
- 딕셔너리 자료형도 특정한 자료를 꺼낼때는 인덱싱을 한다.

```
딕셔너리변수["자료이름"]
```
- 딕셔너리 자료형의 키는 숫자도 가능하다.

```python
b = {"math" : 80, "english" : 90, "history" : 70}
b

=====<p>=====
{'math': 80, 'english': 90, 'history': 70}

b["math"]

=====<p>=====
80

(b["math"] + b["english"]) / 2

=====<p>=====
85.0
```

### 연습문제
- 윤년이 아닌 평년의 경우에 각 달의 수를 저장하는 변수 days
- 각 달을 표시하는 키는 두 글자짜리 문자열로 통일 : 1월-01, 2월-02 ...
- 변수 days를 이용하여 짝수 달의 평균 날짜 수를 구한다.

- 윤년, 평년 확인하는 함수

```python
def leap_year(y) :
    year_type = True
    if (y % 4 == 0) & (y % 400 == 0) :
        year_type = True
    else :
        if y % 100 == 0 :
            year_type = False
        elif y % 4 == 0 :
            year_type = True
        else :
            year_type = False
    return year_type
```
```python
def mean_day(n) :
    # 윤년인지 아닌지 확이하는 함수 호출, 윤년이 아니면 조건문 안의 코드를 실행한다.
    if leap_year(n) == False :

        days = {
            "01" : 31, "02" : 28, "03" : 31, "04" : 30, "05" : 31, \
            "06" : 30, "07" : 31, "08" : 31, "09" : 30, "10" : 31, \
            "11" : 30, "12" : 31}

        total_day = 0
        count = 0

        for i in range(1, 13) :
            if i % 2 == 0 :
                count += 1
                if i < 10 :
                    month = "0" + str(i)
                    day = days[month]
                else :
                    month = str(i)
                    day = days[month]

                total_day = total_day + day

        mean_day = round(total_day / count, 2)

        return print("{}년의 짝수달의 일수의 평균 : {}일".format(n, mean_day))

    else :
        return print("다른 해를 입력하시오.")

# 함수 호출
mean_day(1995)

=====<print>=====
1995년의 짝수달의 일수의 평균 : 30.17일
```

### 리스트와 딕셔너리에 들어가는 자료의 자료형
- 리스트 변수에는 자료형이 같은 것 뿐만 아니라 자료형이 다른 자료들도 담을 수 있다.
    - 숫자, 문자열, 리스트, 딕셔너리도 넣을 수 있다.
- 딕셔너리 변수에도 여러가지 자료형의 자료를 넣을 수 있다. 

```python
# 정수와 문자열
d = [1, 2, 3, "pi"]
d

=====<p>=====
[1, 2, 3, 'pi']

```
```python
# 리스트 안에 리스트가 들어있는 형태
e = [[1, 10], [2, 20]]

print(e[0], e[0][0], e[0][1])

=====<p>=====
[1, 10] 1 10
```

```python
g = {"a" : [1, 2, 3], "b" : {0 : 1, 1 : 2}}

g["a"]

=====<p>=====
[1, 2, 3]

g["a"][0]

=====<p>======
1
```

# 파이썬에서 리스트 자료형 다루기

### 자료의 개수
- len : 리스트 변수에 자료가 몇개 들어 있는지 확인하는 명령어

```python
a = [1, 2, 3]
len(a)

=====<p>=====
3
```

### 수열 생성하기
- range : 0 ~ n-1까지 1씩 증가하는 n개의 숫자를 가지는 수열 리스트를 만들어 준다.
```
list(range(10)) : 0~9
list(range(a, b)) : a <= x < b
list(range(a, b, c)) : a <= x < b, c씩 증가
```

```python
b = list(range(10))
b

=====<p>=====
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]

d = list(range(1, 10, 3))
d

=====<p>=====
[1, 4, 7]
```

### 값 바꾸기
- 갱신 update : 특정한 원소의 값을 다른 값으로 바꾸는 것
- 리스트에 특정한 원소의 값을 갱신하려면 인덱싱한 값에 새로운 값을 대입한다.

```python
# 리스트의 첫번째 데이터를 다른 값으로 바꾸기
d = list(range(1, 10, 3))
d[0] = 100
d

=====<p>=====
[100, 4, 7]
```

### 자료 추가하기
- append : 리스트 변수의 마지막에 자료를 더 추가하는 메서드
    - 메서드 method : 변수 다음에 .을 찍고 쓰는 명령어

```python
e = list(range(4))
e

=====<p>=====
[0, 1, 2, 3]

e.append(4)

=====<p>=====
[0, 1, 2, 3, 4]
```

### 자료 삭제하기
- del : 리스트에서 자료를 하나 삭제하는 명령어

```python
f = list(range(5))
f

=====<p>=====
[0, 1, 2, 3, 4]
```
```python
# 리스트에서 첫번째 데이터 삭제
del f[0]

f

=====<p>=====
[1, 2, 3, 4]
```

### 슬라이싱
- 슬라이싱 slicing : 리스트에서 특정 범위의 자료를 모두 가져오는 방법
- 역 인덱싱 : 음수 인덱스를 사용하여 뒤에서부터 원소를 가져오는 방법
   - 슬라이싱의 뒷부분의 인덱스는 포함되지 않는다.
   - [1:5] : 5 이전까지 출력된다

```python
g = list(range(20))
g

=====<p>=====
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]

g[0:5]

=====<p>=====
[0, 1, 2, 3, 4]

g[10:15]

=====<p>=====
[10, 11, 12, 13, 14]

# 역 인덱싱
g[-5:-2]

=====<p>=====
[15, 16, 17]

g[-3:]

=====<p>=====
[17, 18, 19]

g[-3:-1]

=====<p>=====
[17, 18]
```

### 연습문제
- 10명으로 이루어진 반의 학생 이름
- 전학생이 왔다고 가정하고 이름 추가
- 전학을 간 경우 이름 삭제
- 슬라이싱으로 5번~9번까지 5명의 이름을 담은 새로운 리스트를 만든다.

- 학생의 이름 리스트 생성
```python
nameStudent = ["kim", "jun", "hong", "yeon", "yoo", \
                "goo", "park", "lee", "kang", "ho"]
nameStudent

=====<p>=====
['kim', 'jun', 'hong', 'yeon', 'yoo', 'goo', 'park', 'lee', 'kang', 'ho']
```

- 새로 전학온 학생의 이름 추가
```python
newStudent = "seo"
nameStudent.append(newStudent)

nameStudent

=====<p>=====
['kim',
 'jun',
 'hong',
 'yeon',
 'yoo',
 'goo',
 'park',
 'lee',
 'kang',
 'ho',
 'seo']
```

- 전학간 학생의 이름을 리스트에서 삭제

```python
del nameStudent[5]

nameStudent

=====<p>=====
['kim', 'jun', 'hong', 'yeon', 'yoo', 'park', 'lee', 'kang', 'ho', 'seo']
```

### 복수 할당
- 복수 할당 multiple/unpack assignment : 리스트의 각 원소값을 여러개의 변수에 나누어 넣는 방법
- 자료를 저장할 변수의 갯수와 리스트의 길이가 같아야 한다. 

```python
h = [1, 2, 3]
h1, h2, h3 = h

h1

=====<p>=====
1

h2

=====<p>=====
2

h3

=====<p>=====
3
```

- 복수할당할 변수의 갯수와 리스트의 원소의 갯수가 다르면 에러가 난다.

```python
h4, h5 = h

=====<p>=====
---------------------------------------------------------------------------
ValueError                                Traceback (most recent call last)
C:\Users\Public\Documents\ESTsoft\CreatorTemp/ipykernel_1232/3365798384.py in <module>
----> 1 h4, h5 = h

ValueError: too many values to unpack (expected 2)
```

### 리스트와 반복문을 사용하여 계산하기
- 과목별 점수를 담은 리스트에서 평균값 구하기

```python
a = [90, 85, 95, 80, 90, 100, 85, 75, 85, 80]

sum = 0
for i in range(len(a)) :
    sum = sum + a[i]
average = sum / len(a)
average

>>>

86.5
```

- 두 학생의 과목별 점수 리스트에서 과목별 점수의 합 계산

```python
s = []
a1 = [90, 85, 95, 80, 75, 90, 100, 65, 55, 85]
a2 = [40, 50, 60, 75, 85, 95, 90, 65, 75, 100]

for i in range(len(a1)) :
    s.append(a1[i] + a2[i])
s

>>>

[130, 135, 155, 155, 160, 185, 190, 130, 130, 185]
```

### 리스트의 원소를 직접 반복문에서 사용하기
- 반복문에 리스트의 원소를 직접 사용할 수 있다.
- 반복문에서 사용한 range 는 리스트 만드는 명령어와 같다.

```python
for i in range(5) :
    print(i)

>>>

0
1
2
3
4
```

```python
for i in [0, 1, 2, 3, 4] :
    print(i)

>>>

0
1
2
3
4
```

```python
a = [90, 85, 95, 80, 90, 100, 85, 75, 85, 80]

sum = 0
for ai in a :
    sum = sum + ai
avg = sum / len(a)
avg

>>>

86.5
```

### `enumerate 함수`
- enumerate : 리스트의 원소를 반복하여 꺼내면서 동시에 인덱스 값도 생성해준다.
- 반복문에서 append 메서드를 사용하면 속도가 느려진다. 이럴때는 미리 저장공간을 만들고 해당 위치에 계산 결과를 갱신해야 한다.

```python
for i, e in enumerate(["a", "b", "c"]) :
    print("i = %d, e = %s" % (i, e))

>>>

i = 0, e = a
i = 1, e = b
i = 2, e = c
```

- append 대신에 새로운 리스트 변수를 만들고 해당 인덱스에 값을 갱신한다.
    - 비어있는 리스트 s를 만들고 여기에 값을 갱신한다.
```python
s = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
a1 = [90, 85, 95, 80, 75, 90, 100, 65, 55, 85]
a2 = [40, 50, 60, 75, 85, 95, 90, 65, 75, 100]

for i, (a1i, a2i) in enumerate(zip(a1, a2)) :
    s[i] = a1i + a2i

s

>>>

[130, 135, 155, 155, 160, 185, 190, 130, 130, 185]
```

### 리스트의 리스트
- 리스트 안에 리스트가 들어있는 구조
- 학생이 5명, 각 학생이 10번의 시험에 대한 성적을 갖는다면, 리스트의 리스트로 시험성적을 나타낼 수 있다.
- 중첩 반복문을 사용하여 이중 리스트에서 데이터를 선택할 수 있다.
    - 상위 반복문의 카운터 변수를 하위 반복문의 반복횟수에 넣어 사용할 수 있다.

```python
X = [[85, 60, 50, 76, 35, 84, 98, 99, 100, 55],
    [45, 60, 75, 43, 56, 78, 73, 35, 68, 90],
    [30, 56, 48, 89, 76, 88, 53, 58, 14, 67],
    [89, 67, 68, 87, 72, 62, 56, 79, 90, 68],
    [68, 90, 93, 92, 75, 38, 79, 53, 89, 22]]

# 전체 평균 점수
# num은 시험의 전체 횟수, sum은 모든 시험 점수의 총합

sum = 0
num = 0
for i in range(len(X)) : 
    for j in range(len(X[i])) : 
        num = num + 1
        sum = sum + X[i][j]
    print(num, sum)
    
sum / num    

>>>

10 742
20 1365
30 1944
40 2682
50 3381

67.62
```
### 연습문제
- 학생이 5개 과목 성적
    - X = 4, 3, 2, 3, 4
- 5개 과목 이수학점
    - W = 3, 3, 1, 2, 2
- 이 떄 평균 평점(GPA)은 성적의 단순 평균이 아니라 이수학점을 가중치로 써서 계산한다.
    - 성적과 이수학점을 곱한 값의 총합 즉, 가중합 / 이수학점의 총합
- i번째 과목의 성적을 Xi라고 하고, i번째 과목의 이수학점을 Wi라고 할때 가중평균.
    - W1X1 + W2X2 + W3X3 + W4X4 + W5X5 / W1 + W2 + W3 + W4 + W5
- 이 학생의 평균평점을 구하는 코드를 작성한다.

#### 코드 풀이
- 중첩 반복문을 사용

```
1. score 변수에서 0번쨰 리스트의 원소를 꺼내 과목 성적 변수X에 저장
2. score 변수에서 1번쨰 리스트의 원소를 꺼내 이수 학점 변수W에 저장
   - 이때 이수학점의 총합을 W_sum에 저장
3. X와 W의 데이터를 순서대로 곱하고 더하여 가중한 변수 XW에 저장
4. 최종 평균평점 : XW / W_sum
```

```python
score = [[4, 3, 2, 3, 4], [3, 3, 1, 2, 2]]

X = [0] * len(score[0])
W = [0] * len(score[1])
W_sum = 0

for i in range(len(score)) :   # score의 원소의 갯수 2개 : 0, 1
    for j in range(len(score[i])) :   # 각 원소의 길이 5개 : 0, 1, 2, 3, 4
        if i == 0 :
            X[j] = score[i][j]
        elif i == 1 :
            W[j] = score[i][j]
            W_sum = W_sum + score[i][j]
XW = 0
for h in range(len(score[0])) :
    XW = XW + (X[h] * W[h])

XW / W_sum

>>>

3.3636363636363638
```

#### 다시 간단하게 코딩
- 반복문을 하나만 사용

```python
score = [[4, 3, 2, 3, 4], [3, 3, 1, 2, 2]]
XW = 0
W = 0
for i in range(len(score[0])) :
    XW = XW + (score[0][i] * score[1][i])
    W = W + score[1][i]

XW / W

>>>

3.3636363636363638
```
### zip 함수
- zip : 두 개의 리스트를 합쳐서 각 리스트 원소의 쌍을 원소로 가지는 하나의 리스트를 만들어준다.
- 파이썬에서는 list 명령을 함께 사용해주어야 리스트 기능을 한다.
- 튜플(tuple) 타입으로 원소 쌍이 저장된다. 튜플은 리스트와 사용법이 거의 동일하다.

```python
s = []
a1 = [80, 90, 88, 76, 54, 32, 38, 45, 60, 99]
a2 = [76, 85, 55, 43, 66, 78, 90, 12, 34, 43]

# zip함수로 합한 리스트의 값을 반복문에서 바로 꺼내어 사용

for a1i, a2i in zip(a1, a2) :
    s.append(a1i + a2i)

s

>>>

[156, 175, 143, 119, 120, 110, 128, 57, 94, 142]
```

#### zip 함수에서 리스트안에 인수를 하나만 넣고 * 기호를 붙이면 쌍을 바꿔준다.

```python
a12 = list(zip(a1, a2))
a12

>>>

[(80, 76),
 (90, 85),
 (88, 55),
 (76, 43),
 (54, 66),
 (32, 78),
 (38, 90),
 (45, 12),
 (60, 34),
 (99, 43)]
```

- zip 해서 만든 변수를 다시 zip을 하되 `*`을 붙여주면 쌍의 모양이 바뀐다.

```python
a21 = list(zip(*a12))
a21

>>>

[(80, 90, 88, 76, 54, 32, 38, 45, 60, 99),
 (76, 85, 55, 43, 66, 78, 90, 12, 34, 43)]
```

### 연습문제
- 아래 변수에서 복수할당과 zip 명령을 사용하여 이 변수에서 학생 이름만 있는 변수를 만들어라.

```
x = [
    ["길동", 90],
    ["철수", 80],
    ["영수", 70],
    ["방자", 60]
]
```

#### 코딩
- 복수할당한 후 각 변수를 zip을 합쳐주면 이름만 모을 수 있다.

```python
n1, n2, n3, n4 = x
n1, n2, n3, n4

>>>

(['길동', 90], ['철수', 80], ['영수', 70], ['방자', 60])

name = list(zip(n1, n2, n3, n4))[0]
name

>>>

('길동', '철수', '영수', '방자')
```

- x 변수를 `*`을 붙여 zip 해주면 이름과 점수를 따로 분리할 수 있다.

```python
list(zip(*x))

>>>

[('길동', '철수', '영수', '방자'), (90, 80, 70, 60)]
```

# 파이썬에서 딕셔너리 자료형 다루기

### 자료의 개수
- len : 딕셔너리 자료형의 자료의 갯수를 구해준다.

```python
x = {"a" : 10, "b" : 20}
x

>>>

{'a': 10, 'b': 20}
```

```python
len(x)

>>>

2
```

### 자료의 갱신, 추가, 삭제
- 기존 자료 갱신 : 딕셔너리 자료형을 인덱싱한 후 결과에 바꾸고자 하는 값을 대입한다.

```python
x["a"] = 100
x

>>>

{'a': 100, 'b': 20}
```

- 새로운 자료 추가 : 새로운 키를 인덱싱에 넣고 결과에 새로운 값을 저장한다.

```python
x["c"] = 50
x

>>>

{'a': 100, 'b': 20, 'c': 50}
```

- 자료 삭제 : del 명령 사용

```python
del x["b"]
x

>>>

{'a': 100, 'c': 50}
```

### 키 확인
- in : 특정한 키가 있는지 확인하는 명령어, True, False를 반환한다.

```python
"a" in x

>>>

True

"f" in x

>>>

False
```

### 딕셔너리 자료형의 반복
- 딕셔너리 자료형을 for 반복문에 넣어서 사용할 경우 내부적으로 자료의 순서를 보장하지 않는다.
- for 문에 딕셔너리 자료형을 사용하는 방법
    - 키만 반복하는 경우 : for i in x, for i in x.keys()
    - 값만 반복하는 경우 : for i in x.values()
    - 키와 값 쌍을 반복하는 경우 : for k, v in x.items() :

#### key 반환

```python
for k in x :
    print(k)

>>>

a
c

x.keys()

>>>

dict_keys(['a', 'c'])

for k in x.keys() :
    print(k)

>>>

a
c
```

#### vlaue 반환

```python
x.values()

>>>

dict_values([100, 50])

for v in x.values() :
    print(v)

>>>

100
50
```

#### key, value 반환

```python
for k, v in x.items() : 
    print("key [%s] => vlaue [%d]" % (k, v))

>>>

key [a] => vlaue [100]
key [c] => vlaue [50]
```

### 연습문제
- for 문을 사용하여 딕셔너리 자료에서 자료를 특정한 양식으로 출력하시오.

```
data = {
    "철수" : 98,
    "영희" : 80,
    "순이" : 100,
    "돌이" : 70
}
```
#### 코딩

```python
sum = 0
for k, v in data.items() :
    print("{}    {}".format(k, v))
    sum = sum + v
    if k == "돌이" :
        print("=" * 13)
        print("평균    {}".format(sum // len(data)))

>>>

철수    98
영희    80
순이    100
돌이    70
=============
평균    87
```

- f문자열의 형식지정 문자열 사용하여 출력

```python
score_sum = 0
for k, v in data.items() :
    print(f"{k:<5}", f"{v:>6}")
    score_sum = score_sum + v
    if k == "돌이" :
        m = "평균"
        mean = score_sum // len(data)
        print("=" * 16)
        print(f"{m:<5}", f"{mean:>6}")

>>>

철수        98
영희        80
순이       100
돌이        70
================
평균        87
```

# 파이썬 객체지향 프로그래밍

### 객체
- 프로그램이 어떤 작업을 수행하기 위해 필요한 요소
    - 데이터 : 변수에 저장해서 사용
    - 데이터를 조작하는 행위 : 함수로 구성해서 실행
- **객체 object, instance** : 서로 연관된 데이터와 그 데이터를 조작하기 위한 함수를 하나의 집합에 모아 놓은 것
- **멤버 member, 속성 attribute** : 객체의 원소가 되는 변수나 함수
- **메서드 method** : 객체의 속성인 함수

#### 사각형의 면적을 구하는 프로그램에서 필요한 변수와 함수
- 가로 길이, 세로 길이를 넣을 변수
- 두 길이를 곱해서 면적을 구하는 함수

```python
# 객체지향을 사용하지 않고 파이썬으로 구현하면 다음과 같다.
# 여기에서 사각형의 가로길이 h, 세로길이 v, 면적을 구하는 함수 area는 제각기 떨어져 있다.


h = 10
v = 20

def area(h, v) :
    return h * v

a = area(h, v)
print(a)

>>>

200
```

### 객체지향 프로그래밍에서는 이 세가지를 하나의 객체 object로 묶을 수 있다.
- r : 객체
    - h, v : 변수
    - area() : 함수
- 객체 r에 변수와 함수가 하나로 합쳐진다.
- 객체 r에서 속성/멤버 또는 매서드를 꺼내려면 이름 뒤에 점을 붙이고 속성 이름을 입력한다.
    - 속성, 멤버 : 객체의 원소가 되는 변수 또는 함수를 일컫는 개념
    - 매서드 : 객체의 원소가 되는 함수

```python
class Rectangle(object) :

    def __init__(self, h, v) :
        self.h = h
        self.v = v

    def area(self) :
        return self.h * self.v
```

- 클래스를 r에 저장하여 객체를 만들고, r 객체의 멤버인 area() 함수를 호출한다. 면적이 계산된다.

```python
r = Rectangle(10, 20)
a = r.area()
print(a)

>>>

200
```

- r 객체의 h 속성값 호출

```python
r.h

>>>

10
```

- r 객체의 v 속성값 호출

```python
r.v

>>>

20
```

### `클래스`
- 객체지향 프로그래밍에서 객체를 만들려면 항상 클래스(class)라는 것을 만든 후에 클래스를 이용하여 객체를 만들어야 한다.
- 객체와 클래스의 관계는 붕어빵과 붕어빵틀의 관계와 같다.
- 길이에 해당하는 속성 h와 v를 갖는 클래스를 만들어 놓으면 이 속성을 갖는 실제 사각형을 얼마든지 만들 수 있다.

```python
a = Rectangle(1, 1)
b = Rectangle(2, 1)
c = Rectangle(4, 2)
d = Rectangle(6, 3)
e = Rectangle(8, 5)

# 객체의 area() 멤버 호출 : 면적 계산
print(a.area())
print(b.area())
print(c.area())
print(d.area())
print(e.area())

>>>

1
2
8
18
40
```

### 생성자

```
class 클래스이름(object) :
    
    def __init__(self, 속성값1, 속성값2, 속성값3) :
        self.속성이름1 = 속성값1
        self.속성이름2 = 속성값2
        self.속성이름3 = 속성값3
```

- 생성자 constructor : 클래스 안에 `__init__` 함수, 클래스의 정의에서 가장 중요한 함수
- 속성값 인수는 입력하지 않아도 된다.
- 객체를 생성할 때는 클래스이름을 함수 처럼 호출해야 한다. 이때 `__init__` 함수가 호출 된다. 
- 생성자 함수 내부에서는 생성자를 호출할 때 넣은 입력변수=인자의 값을 속성값으로 저장한다. 

### 연습문제
- 삼각형의 넓이를 계산하기 위한 클래스를 만든다.
- 속성 : 밑변의 길이 b, 높이 h 변수
- 매서드 : 삼각형의 넓이 계산하는 area() 함수

```python
class Triangle(object) :

    def __init__(self, b, h) :
        self.b = b
        self.h = h

    def area(self) :
        return 1/2 *(self.b * self.h)
```

- Triangle() 클래스를 o 객체로 만든다. 

```python
o = Triangle(2, 5)
o

>>>

<__main__.Triangle at 0x1f18c0c68c8>
```

- 객체의 멤버변수(속성값), 매서드 확인

```python
o.b

>>>

2

o.h

>>>

5

o.area()

>>>

5.0
```

- 여러개의 객체 만들기

```python
oo = Triangle(10, 8)
ooo = Triangle(3, 6)

print(oo.area())
print(ooo.area())

>>>

40.0
9.0
```

### 연습문제
- 사각 기둥의 부피를 계산하기 위한 클래스를 만든다.
- 속성
    - 변수 : 밑면의 가로길이 a, 밑면의 세로길이 b, 높이 h
    - 메서드 : 부피 계산하는 volume()
    - 메서드 : 겉넓이를 계산하는 surface()

```python
class Squarpillar(object) :

    def __init__(self, a, b, h) :
        self.a = a
        self.b = b
        self.h = h

    def volume(self) :
        return self.a * self.b * self.h

    def surface(self) :
        return (2 * (self.a * self.b)) + (2 * (self.a * self.h)) + (2 * (self.h * self.b))
```

- 클래스를 calc 객체에 저장하고, 각각의 멤버변수(속성값), 매서드 호출

```python
calc = Squarpillar(2, 4, 5)
calc.a

>>>

2

calc.b

>>>

4

calc.h

>>>

5

calc.volume()

>>>

40

calc.surface()

>>>

76
```

### 게임 캐릭터와 객체 
- 게임 캐릭터 클래스 만들기
    - 플레이어의 캐릭터
    - 속성 : 캐릭터의 능력치, 경험치 등, 변수
    - 메서드 : 캐릭터를 움직이는 방법, 이동, 공격 등, 함수

```python
class Character(object) :

    def __init__(self) :
        self.life = 1000

    def attacked(self) :
        self.life -= 10
        print("공격받음! 생명력 = ", self.life)
```

- Character() 클래스를 각각의 객체로 만들기

```python
a = Character()
b = Character()
c = Character()

# 객체의 life 속성값 확인
a.life, b.life, c.life

>>>

(1000, 1000, 1000)

# 객체의 attacked() 매서드 호출
a.attacked()

>>>

공격받음! 생명력 =  990
```

### `클래스 상속`
- **클래스 상속 class inheritance** : 이미 만들어진 클래스 코드를 재사용하여 다른 클래스를 생성하는 방법. 상속 과정에서 공통으로 사용하는 속성이나 메서드는 두 번 반복해서 코딩할 필요가 없다.
- **자식 클래스 child class** : 상속을 받는 클래스
- **부모 클래스 parent class** : 상속의 대상이 되는 클래스

```
class 자식클래스이름(부모클래스이름) :

    def __init__(self, 속성값1, 속성값2) :
        super(자식클래스이름, self).__init__()
        자식 클래스의 초기화 코드
```

- `super(자식클래스이름, self).__init__()` : 부모 클래스의 초기화 생성자를 호출하는 부분
- Character 부모 클래스에서 초기화 생성자를 호출하면 life 속성값을 초기화한다. 따라서 자식 클래스에서는 이 속성값을 초기화할 필요가 없다.

```python
# 부모 클래스 : Character -> 자식 클래스 : Warrior, Wizard
# 부모 클래스의 속성인 life와 attacked() 메서드를 갖게 된다.

class Warrior(Character) :

    def __init__(self) :
        # 부모 클래스의 초기화 속성값 life를 호출

        super(Warrior, self).__init__()
        self.strength = 15
        self.intelligence = 5

class Wizard(Character) :

    def __init__(self) :
        super(Wizard, self).__init__()
        self.strength = 5
        self.intelligence = 15
```

- 객체 생성
- 객체의 life 속성값(멤버변수)은 부모클래스에서 상속받은 값이다.

```python
a = Warrior()
b = Wizard()

a.life, b.life

>>>

(1000, 1000)
```

- 각 객체의 속성값 호출
```python
a.strength, b.strength

>>>

(15, 5)

a.intelligence, b.intelligence

>>>

(5, 15)
```

- 부모 클래스에 상속받은 attacked() 매서드 호출

```python
a.attacked()

>>>

공격받음! 생명력 =  990

b.attacked()

>>>

공격받음! 생명력 =  990
```

### 매서드 오버라이딩
- **매서드 오버라이딩 method overriding** : 여러 클래스에 걸쳐서 같은 이름의 메서드를 만드는 것
- 부모 클래스, 전사 클래스, 마법사 클래스에 공통으로 attack 메서드가 있다. 각각하는 일이 다를 때는 메서드 오버라이딩으로 메서드를 클래스별로 구현할 수 있다. 
- 즉 같은 멤버함수를 각 클래스 별로 따로 만들고 속성값을 다르게 하는 것

```python
class Character(object) :

    
    def __init__(self) :
        self.life = 1000
        self.strength = 10
        self.intelligence = 10

    def attacked(self) : # 매서드
        self.life -= 50
        print("공격받음! 생명력 = ", self.life)

    def attack(self) : # 매서드
        print("공격하라!")

# Character 클래스를 상속받는다.
# 상속 받을 때 attack() 매서드는 매서드 오버라이딩으로 자식 클래스 별로 다시 만들어준다.
class Warrior(Character) :

    
    def __init__(self) :
        super(Warrior, self).__init__()
        self.strength = 15
        self.intelligence = 5

    def attack(self) : # 매서드
        print("육탄공격!")


class Wizard(Character) : 
    
    
    def __init__(self) : 
        super(Wizard, self).__init__()
        self.strength = 5
        self.intelligence = 15
        
    def attack(self) : # 매서드
        print("마법공격!")	
```

- 객체 생성후 각 객체별 속성값 호출

```python
a = Character()
b = Warrior()
c = Wizard()

a.life, b.life, c.life

>>>

(1000, 1000, 1000)

a.strength, b.strength, c.strength

>>>

(10, 15, 5)

a.intelligence, b.intelligence, c.intelligence

>>>

(10, 5, 15)

# attacked() 매서드 호출
a.attacked()

>>>

공격받음! 생명력 =  950

b.attacked()

>>>

공격받음! 생명력 =  950

c.attacked()

>>>

공격받음! 생명력 =  950

# 매서드 오버라이딩으로 만든 attack() 매서드 호출
a.attack()

>>>

공격하라!

b.attack()

>>>

육탄공격!

c.attack()

>>>

마법공격!
```

### 연습문제
- 게임 캐릭터 코드에서 attacked 메서드도 오버라이딩을 하여 전사와 마법사가 공격을 받을때 life 속성값이 다르게 감소하도록 한다. 

```python
class Character(object) :


    def __init__(self) :
        self.life = 1000

    def attacked(self) :
        self.life -= 50
        print("공격받음! 생명력 = ", self.life)

    def attack(self) :
        print("공격!")


class Warrior(Character) :

    def __init__(self) :
        super(Warrior, self).__init__()

    def attacked(self) :
        self.life -= 100
        print("워리어 공격받음! 생명력 = ", self.life)

    def attack(self) :
        print("워리어 육탄공격!")


class Wizard(Character) : 
    
    def __init__(self) : 
        super(Wizard, self).__init__()
        
    def attacked(self) : 
        self.life -= 200
        print("마법사 공격받음! 생명력 = ", self.life)
        
    def attack(self) : 
        print("마법사 마법공격!")
```

- 객체 생성 후 attacked() 매서드 호출
    - life 속성값의 감소가 객체마다 다르다.

```python
a = Character()
b = Warrior()
c = Wizard()

a.attacked()

>>>

공격받음! 생명력 =  950

b.attacked()

>>>

워리어 공격받음! 생명력 =  900

c.attacked()

>>>

마법사 공격받음! 생명력 =  800
```

### 연습문제
- 다음과 같이 자동차를 나타내는 Car 클래스를 구현한다.
    - 속성 : 최고속도 max_speed, 현재 속도 speed
    - max_speed = 160, speed = 0
    - 메서드 : speed_up을 호출하면 speed 20 증가, speed_down 호출하면 speed 20 감소
    - speed는 max_speed를 넘을 수 없다. 0 미만 감소할 수 없다.
    - 메서드 호출시 속도정보 출력, 명시적인 반환값을 가지지 않는다.

```python
# if 조건문을 사용하여 속성값의 범위를 제한 해준다.

class Car(object) :

    def __init__(self) :
        self.max_speed = 160
        self.speed = 0

    def speed_up(self) :
        self.speed += 20
        if self.speed > self.max_speed :
            self.speed = 160
            print("초과속도 입니다.")
        else :
            print("현재속도 = ", self.speed)

    def speed_down(self) :
        self.speed -= 20
        if self.speed < 0 :
            self.speed = 0
            print("정지상태 입니다.")
        else :
            print("현재속도 = ", self.speed)
```

- 객체 생성 후 속성값 호출

```python
car = Car()

car.max_speed

>>>

160

car.speed

>>>

0
```

- car 객체의 speed_up() 매서드를 반복 호출 : max_speed=160 이상이 되면 초과속도 가 출력된다.

```python
for i in range(10) :
    car.speed_up()

>>>

현재속도 =  20
현재속도 =  40
현재속도 =  60
현재속도 =  80
현재속도 =  100
현재속도 =  120
현재속도 =  140
현재속도 =  160
초과속도 입니다.
초과속도 입니다.
```

```python
for i in range(10) :
    car.speed_down()

>>>

현재속도 =  140
현재속도 =  120
현재속도 =  100
현재속도 =  80
현재속도 =  60
현재속도 =  40
현재속도 =  20
현재속도 =  0
정지상태 입니다.
정지상태 입니다.
```

### 연습문제
- Car 클래스를 기반으로 SportCar와 Truck이라는 두개의 자식 클래스를 구현한다.
- SportCar 클래스
    - max_speed 속성 = 200
    - speed_up, speed_down 매서드 호출시 45 증가, 감소
- Truck 클래스
    - max_speed 속성 = 100
    - speed_up, speed_down 매서드 호출시 15 증가, 감소

```python
# Car 클래스를 상속받는다.
# 매서드 오버라이딩으로 상속받은 매서드를 재구성한다.
class SportCar(Car) :


    def __init__(self) :
        super(SportCar, self).__init__()
        self.max_speed = 200

    def speed_up(self) :
        self.speed += 45
        if self.speed > self.max_speed :
            self.speed = self.max_speed
            print("초과속도 속도를 줄이세요. speed = ", self.speed)
        else :
            print("현재속도 speed = ", self.speed)

    def speed_down(self) :
        self.speed -= 45
        if self.speed < 0 :
            self.speed = 0
            print("정지상태 입니다. speed = ", self.speed)
        else :
            print("현재속도 speed = ", self.speed)


class Truck(Car) : 


    def __init__(self) : 
        super(Truck, self).__init__()
        self.max_speed = 100
        
    def speed_up(self) : 
        self.speed += 15
        if self.speed > self.max_speed : 
            self.speed = self.max_speed
            print("초과속도 속도를 줄이세요. speed = ", self.speed)
        else : 
            print("현재속도 speed = ", self.speed)
        
    def speed_down(self) : 
        self.speed -= 15
        if self.speed < 0 : 
            self.speed = 0
            print("정지상태 입니다. speed = ", self.speed)
        else : 
            print("현재속도 speed = ", self.speed)	    
```

- 객체 생성

```python
sportcar = SportCar()
truck = Truck()
```

- sportcar 객체의 속성값과 매서드 호출

```python
sportcar.max_speed

>>>

200

sportcar.speed

>>>

0

# speed_up() 매서드를 반복 호출 : 속도 증가
for i in range(5) :
    sportcar.speed_up()

>>>

현재속도 speed =  45
현재속도 speed =  90
현재속도 speed =  135
현재속도 speed =  180
초과속도 속도를 줄이세요. speed =  200

# speed_down() 매서드를 반복 호출 : 속도 감소
for i in range(10) :
    sportcar.speed_down()

>>>

현재속도 speed =  155
현재속도 speed =  110
현재속도 speed =  65
현재속도 speed =  20
정지상태 입니다. speed =  0
정지상태 입니다. speed =  0
정지상태 입니다. speed =  0
정지상태 입니다. speed =  0
정지상태 입니다. speed =  0
정지상태 입니다. speed =  0
```

- truck 객체의 속성값과 매서드 호출

```python
truck.max_speed

>>>

100

truck.speed

>>>

0

for i in range(10) :
    truck.speed_up()

>>>

현재속도 speed =  15
현재속도 speed =  30
현재속도 speed =  45
현재속도 speed =  60
현재속도 speed =  75
현재속도 speed =  90
초과속도 속도를 줄이세요. speed =  100
초과속도 속도를 줄이세요. speed =  100
초과속도 속도를 줄이세요. speed =  100
초과속도 속도를 줄이세요. speed =  100

for j in range(10) :
    truck.speed_down()

>>>

현재속도 speed =  85
현재속도 speed =  70
현재속도 speed =  55
현재속도 speed =  40
현재속도 speed =  25
현재속도 speed =  10
정지상태 입니다. speed =  0
정지상태 입니다. speed =  0
정지상태 입니다. speed =  0
정지상태 입니다. speed =  0
```

### 특수 메서드
- 스페셜 메서드 special methods : 메서드 이름 앞뒤에 밑줄underscore 2개 붙어있는 메서드
- `__repr__` representation : 변수는 `__repr__` 이라는 메서드를 가지고 있다. 변수를 호출하면 이 메서드가 호출된다.
    - 기본적으로 클래스 이름과 변수가 위치하고 있는 메모리 주소를 <> 안에 써서 반환해준다.
    - 이것을 수정하면 클래스 객체를 호출할 때 출력되는 내용을 바꿀 수 있다.
    - 객체만 입력해도 객체의 정보를 출력할 수 있다.
- `__str__` : 변수를 str에 넣으면 문자열로 변환해주는 메서드
    - str(객체명) : 문자열 타입으로 반환해준다.
    - 이것을 수정하면 str() 변환시 출력되는 내용을 바꿀 수 있다.
- `__getitem__` : 이 메서드를 정의하면 마치 리스트나 사전처럼 [] 기호를 사용한 인덱싱을 할 수 있다.
    - 이것을 수정하면 a["입력값"] 이러한 형태로 사용하여 특정한 알고리즘을 실행할 수 있다. 

- 클래스 생성

```python
class Complex(object) :

    def __init__(self, realpart, imagpart) :
        self.r = realpart
        self.i = imagpart
```

- 객체 생성

```python
c = Complex(1, 2)
c

>>>

<__main__.Complex at 0x2571baca448>
```

- 객체의 str 매서드 확인

```python
str(c)

>>>

'<__main__.Complex object at 0x000002571BACA448>'
```

#### repr 메서드와 str 메서드를 새로 정의하여 오버라이딩 한다.
- 자식 클래스 생성
- Complex 부모 클래스 상속
- 스페셜 매서드들의 출력 값을 변경한다. 
    - repr 매서드는 객체를 호출할 때 반환되는 내용을 저장하는 매서드이다.
    - str 매서드는 str(객체)를 호출할 때 반환되는 내용을 저장하는 매서드이다.

```python
class Complex2(Complex) :
    
    # repr 매서드의 반환 내용을 변경
    def __repr__(self) :
        return "Complex : real = %f img = %f" % (self.r, self.i)
    
    # str 매서드의 반환 내용을 변경
    def __str__(self) :
        return "[for str] " + self.__repr__()
```

- 객체 생성

```python
c2 = Complex2(1, 1)
c2

>>>

Complex : real = 1.000000 img = 1.000000

str(c2)

>>>

'[for str] Complex : real = 1.000000 img = 1.000000'
```

#### getitem 스페셜 매서드 변경
- 새로운 자식 클래스 생성
    - Complex2 클래스를 상속 받는다. 스페셜 매서드가 수정된 클래스이다.
- getitem 매서드의 속성값을 변경한다. 
- 객체를 호출할 때 특정한 값을 인덱싱하면 특정한 값을 반환해준다. 객체의 아이템 같은 개념.

```python
class Complex3(Complex2) :

    def __getitem__(self, key) :
        if key == "r" :
            return self.r
        if key == "i" :
            return self.i
```

- 객체 생성

```python
c3 = Complex3(1, 2)

>>>

Complex : real = 1.000000 img = 2.000000
```

- getitem 매서드 호출

```python
c3["i"]

>>>

2

c3["r"]

>>>

1

c3.__getitem__("r")

>>>

1

c3.__getitem__("i")

>>>

2
```

### 연습문제
- 학생의 학번, 이름, 수학 성적, 영어 성적을 저장할 수 있는 클래스를 만들고 평균 성적을 출력하는 메서드를 추가한다.
- 주피터 노트북에서 이 클래스 객체의 이름을 입력하면 바로 이름과 학번이 나와야한다.
- str 명령을 수행하면 이름을 반환한다.
- 수학과 영어 성적을 읽을 수 있어야 한다.
    - obj["math"], obj["english"]

```python
class StudentInfo(object) :


    def __init__(self, name, number, math, english) :
        self.number = number
        self.name = name
        self.math = math
        self.english = english

    def mean(self) :
        return (self.math + self.english) / 2

    def __repr__(self) :
        return "name : %s, number : %d" % (self.name, self.number)

    def __str__(self) :
        return "name : %s" % (self.name)

    def __getitem__(self, key) :
        if key == "math" :
            return self.math
        if key == "english" :
            return self.english
```

- 객체 생성
    - repr 값이 반환 된다 : name, number 속성값을 반환한다.

```python
s_info = StudentInfo("hong", 1234, 90, 100)
s_info

>>>

name : hong, number : 1234
```

- mean() 매서드 호출
    - math와 english 속성값의 점수 평균계산

```pyhon
s_info.mean()

>>>

95.0
```

- str 매서드를 호출하면 name이 반환된다.

```python
str(s_info)

>>>

'name : hong'
```

- getitem 매서드를 호출하면 특정값이 반환되다.
    - "math", "english"를 읽을 수 있다.

```python
s_info["math"]

>>>

90

s_info["english"]

>>>

100
```

# 파이썬 패키지 사용하기

### 패키지 임포트
- 패키지 임포트 import : 파이썬 패키지를 사용하도록 설정하는 것
- 패키지를 사용하려면 해당 패키지를 파이썬에서 사용할 수 있도록 설정하는 명령을 실행해야 한다.

```
import 패키지이름
```

- 패키지이름은 일반적으로 패키지를 부르는 이름과 다를 수 있다.
- 패키지이름이 너무 길면 패키지이름을 짧게 할 수 있다.

```
import 패키지이름 as 패키지별명
```

### 패키지 내용 살펴보기
- **dir** : 임포트된 패키지 안의 내용을 살펴보는 방법
    - dir(패키지이름 또는 패키지별명)
- 대부분의 패키지는 하위 패키지가 있는데 상위 패키지를 임포트할 때 자동으로 임포트 되는 것도 있지만, 그렇지 않은 것도 있다.
- 직접 임포트 해줘야 한다.

- 사이킷런 패키지 임포트하고 dir()로 패키지 내용 확인
    - 여러가지 스페셜 매서드와 속성값(멤버변수)들이 나온다.

```python
import sklearn as sk

# 패키지의 내용을 보여준다.
dir(sk)

>>>

['__SKLEARN_SETUP__',
 '__all__',
 '__builtins__',
 '__cached__',
 '__check_build',
 '__doc__',
 '__file__',
 '__loader__',
 '__name__',
 '__package__',
 '__path__',
 '__spec__',
 '__version__',
 '_config',
 '_distributor_init',
 'base',
 'clone',
 'config_context',
 'exceptions',
 'externals',
 'get_config',
 'logger',
 'logging',
 'os',
 'random',
 'set_config',
 'setup_module',
 'show_versions',
 'sys',
 'utils']
```

- 사이키런 패키지의 preprocessing 서브패키지 임포트
    - 클래스, 매서드, 속성값들 반환

```python
import sklearn.preprocessing

dir(sklearn.preprocessing)

>>>

['Binarizer',
 'FunctionTransformer',
 'KBinsDiscretizer',
 'KernelCenterer',
 'LabelBinarizer',
 'LabelEncoder',
 'MaxAbsScaler',
 'MinMaxScaler',
 'MultiLabelBinarizer',
 'Normalizer',
 'OneHotEncoder',
 'OrdinalEncoder',
 'PolynomialFeatures',
 'PowerTransformer',
 'QuantileTransformer',
 'RobustScaler',
 'SplineTransformer',
 'StandardScaler',
 '__all__',
 '__builtins__',
 '__cached__',
 '__doc__',
 '__file__',
 '__loader__',
 '__name__',
 '__package__',
 '__path__',
 '__spec__',
 '_csr_polynomial_expansion',
 '_data',
 '_discretization',
 '_encoders',
 '_function_transformer',
 '_label',
 '_polynomial',
 'add_dummy_feature',
 'binarize',
 'label_binarize',
 'maxabs_scale',
 'minmax_scale',
 'normalize',
 'power_transform',
 'quantile_transform',
 'robust_scale',
 'scale']
```

### 패키지에 포함된 함수(매서드) 등을 사용하기
- 패키지에 포함된 함수 등을 사용방법
    - 패키지이름.(함수이름)
    - 패키지별명.(함수이름)

```python
import numpy as np

np.arange(10)

>>>

array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

### 선택적 임포트
- 패키지 임포트시 특정한 명령어들만 선택적으로 임포트할 수도 있다.
```
from 패키지이름 import 명령어
from 패키지이름 import 명령어1, 명령어2, 명령어3
```
- 패키지를 선택적으로 임포트한 경우 패키지이름과 마침표 없이 바로사용 가능
- `와일드 임포트 wild import` : 선택적 임포트를 할 때 명령어 이름 대신 `*`기호를 사용하면 패키지안의 모든 명령 임포트 할 수 있다.
- 와일드 임포트시 기존의 변수나 함수를 덮어 쓸 때가 있으므로 주의해서 실행해야한다.

```python
from numpy import arange

arange(10)

>>>

array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
```

#### 동일한 이름의 함수에 새로 임포트한 패키지의 동일한 명령어가 덮어 씌어진다.
- 즉 와일트 임포트는 주의해서 사용해야 한다.
- 중복되는 이름의 다른 함수가 영향을 받을 수 있다.

```python
def f() :
     print("I am f function")

f()

>>>

I am f function
```

- 사이파이의 stats 서브패키지의 명령어를 와일드 임포트하면
- f분포 명령어가 임포트되어 f() 함수에 덮어씌워져 실행이 안된다.

```
from scipy.stats import *

f()

>>>

...

TypeError: _parse_args() missing 2 required positional arguments: 'dfn' and 'dfd'
```

# 파이썬의 자료형

### 자료형
- 프로그램이 실행되려면 컴퓨터는 각 변수에 어떤 종류의 값이 들어가 있는지 알아야 한다.
    - 숫자, 문자열, 리스트, 튜플, 딕셔너리, 함수, 클래스 등...
- 값이 어떤 유형이냐에 따라서 저장하는 방식이나 계산하는 방법이 다르기때문이다.
    - `자료형 data type, 타입 type` : 값의 종류
- 정수 1과 문자열 "1"의 메모리를 확인하면 차이가 난다. 즉 저장하는 방식이 다르기 때문이다.
- `변수의 메모리 크기 확인 : sys 패키지의 getsizeof 명령 사용`

### 파이썬의 자료형
- 변수나 값의 자료형을 확인하는 방법 : type(변수이름)
    - NoneType
    - bool
    - int
    - float
    - complex
    - str
    - tuple
    - list
    - dict
    - function

- getsizeof 명령어 임포트
    - 각 자료형별로 메모리 크기가 다르다.

```python
from sys import getsizeof

a = 1
getsizeof(a)

>>>

28

b = "1"
getsizeof(b)

>>>

50

c = 88833399283018
getsizeof(c)

>>>

32

d = "88833399283018"
getsizeof(d)

>>>

63
```

#### 복소수 사용할 때는 뒤에 j를 붙인다.

```python
type(2  + 3j)

>>>

complex
```

#### 함수도 function이라는 자료형에 속한다.

```python
def f() :
    return 1

type(f)

>>>

function
```

### 자료형과 클래스
- 파이썬에서는 자료형과 클래스는 같은 의미로 생각할 수 있다.
- 즉 자료형도 클래스이다.
- 클래스를 알고 싶으면 `__class__` 속성을 확인

```python
a = 1
type(a)

>>>

int

a.__class__

>>>

int

b = [1, 2, 3]
type(b)

>>>

list

b.__class__

>>>

list
```

#### `__main__`
- 클래스 앞에 붙은 `__main__` 은 클래스가 정의 된 모듈을 의미한다.
- 파일의 이름이다.
- REPL 환경에서 입력하는 코드는 `__main__` 으로 가정한다.

```python
class C(object) :
    pass

c = C()
type(c)

>>>

__main__.C
```

### 연습문제
- 오늘 날짜를 나타내는 문자열과 생일을 나타내는 문자열이 다음과 같을 때 만 나이를 구하시오.
- today = "2020-10-25"
- birthday = "2020-11-21"

```python
today = "2020-10-25"
type(today)

>>>

str

birthday = "2020-11-21"
type(birthday)

>>>

str

# 날짜를 정수로 자료형 변환하여 일수를 계산
today_t = today.replace("-", "")
birthday_t = birthday.replace("-", "")

int(today_t) - int(birthday_t)

>>>

-96
```

### 불변형 자료형과 변형 자료형
- 자료형의 두 가지 종류
    - 불변형 immutable : 정수, 실수, 문자열, 튜플 
    - 변형 mutable : 리스트, 딕셔너리
- 불변형 자료형은 변환할 때 메모리에 저장된 데이터 전체를 모두 없애고 새로 만들어진다.
- 변형 자료형은 할당된 메모리를 그냥 놔두고 메모리에 씌여있는 내용=값만 바꾼다.

#### x라는 변수에 정수를 입력하는 경우 (불변형 자료형의 변형)
- 이름 공간 (name space)에 x라는 변수 이름이 생긴다.
- 메모리의 특정 위치에 1이라는 값이 씌여진다.
- 씌여진 메모리 위치 주소를 알려면 `*id*` 명령을 사용한다.
    - 이름공간에 x라는 변수로 공간이 생기고 이것에 1을 할당하면 메모리 주소값이 부여된다.
- 변수 x의 값을 2로 바꾸면 메모리상의 해당 위치의 값이 바뀌는 것이 아니라 메모리의 다른 위치에 2가 씌여지고 이름공간의 x는 새로운 위치를 가리키게 된다. 
    - 즉 새로운 주소에 바뀐 값이 입력된다. 위치공간의 x는 새로운 주소를 가리킨다.

#### x라는 변수에 리스트를 입력하는 경우 (변형 자료형의 변형)
- 변수 x는 리스트 자료형을 가리키고(해당 메모리의 주소), 이 리스트 자료형은 원소인 불변형 자료형인 정수 1을 가리킨다.
- 리스트의 원소를 다른값을 바꾸면, 리스트의 위치는 변하지 않지만 바꾼 자리의 원소의 값의 위치가 바뀐다.

#### x라는 변수에 튜플을 입력하는 경우 (불변형 자료형)
- 원소가 가리키는 내용만 바꿀 수 없다.

```python
x = 1
x

>>>

1

# 값 1에 씌여진 메모리의 위치 주소 확인
# 변수 x는 이름공간에 들어가있고, 이 이름공간이 값 1의 메모리주소를 가리키게 되는 방식.
id(x)

>>>

140719686787488

x = 2
x

>>>

x

# 값 2에 씌어진 메모리의 위치 주소를 x의 이름공간이 가리키게 된다.
id(x)

>>>

140719686787520
```

#### 튜플의 내용은 바꿀 수 없다.
- 바꾸려면 기존의 튜플을 사제하고 다시 만들어야 한다.
- 즉 이름공간과 직접 연결된 자료형의 위치 주소를 아예 새로 만들어야 한다.
- 불변형 자료형의 특징이다.

```python
x = (1, )
x

>>>

(1,)

x[0] = 2

>>>

TypeError: 'tuple' object does not support item assignment
```

# 파이썬에서 날짜와 시간 다루기

### 날짜와 시간 데이터
- 날짜와 시간은 파이썬에서 제공하는 자료형은 아니다.
- 데이터 분석에서 사용되는 중요한 자료형이므로 패키지를 사용해서 다룬다.

### datetime 패키지
- `datetime 클래스` : 날짜와 시간을 함께 저장하는 클래스
- datetime 클래스를 생성한 시점의 시간이 저장된다. 아래 메서드와 속성들은 이 저장된 시간을 반영한다.
    - 패키지 이름과 같으므로 사용 주의해야 한다.
    - 클래스 이름이 대문자로 시작하지 않는다.
    - 객체를 생성하지 않고도 바로 클래스에서 사용할 수 있는 클래스 메서드를 제공한다.
    - 메서드 :
        - now() : 현재 시각 출력
        - weekday() : 요일 반환 (0 : 월, 1 : 화 ~ 6 : 일)
        - strftime : 문자열 반환, 어떤 형식으로 문자열을 만들지 형식 문자열을 인수로 받는다.
        - date : 날짜 정보만 가지는 date 클래스 객체 반환
        - tiem : 시간 정보만 가지는 time 클래스 객체 반환
    - 속성 :
        - year 연도
        - month 월
        - day 일
        - hour 시
        - minute 분
        - second 초
        - microsecond 마이크로 초(백만분의 일초)
- `date 클래스` : 날짜만 저장하는 클래스
- `time 클래스` : 시간만 저장하는 클래스
- `timedalta 클래스` : 시간 구간 정보를 저장하는 클래스

#### datetime 패키지 임포트

```python
import datetime as dt
```

#### datetime 패키지의 datetime 클래스 객체 만들기
- 여러가지 클래스 메서드들
- 현재 시점의 datetime을 반환해 준다.

```python
x = dt.datetime.now()
x

>>>

datetime.datetime(2022, 3, 7, 17, 57, 17, 791445)
```

- weekday() 매서드를 호출하면 datetime의 요일을 숫자로 반환한다.
- 0 : 월요일, 1 : 화요일 ...

```python
x.weekday() 

>>>

0
```

#### strftime() 클래스 메서드는 형식 문자열을 인수로 갖는다.
- 이 밖에도 여러가지 형식 문자열을 지정 할 수 있다.
- https://docs.python.org/3.8/library/datetime.html#strftime-and-strptime-format-codes
- %Y : 앞의 빈자리를 0으로 채우는 **4자리 연도 숫자**
- %m : 앞의 빈자리를 0으로 채우는 **2자리 월 숫자**
- %d : 앞의 빈자리를 0으로 채우는 **2자리 일 숫자**
- %H : 앞의 빈자리를 0으로 채우는 **24시간 형식 2자리 시간 숫자**
- %M : 앞의 빈자리를 0으로 채우는 **2자리 분 숫자**
- %S : 앞의 빈자리를 0으로 채우는 **2자리 초 숫자**
- %A : 영어로 된 **요일 문자열**
- %B : 영어로 된 **월 문자열**

```python
# 영어로 된 요일, 두자리 월 숫자, 영어로 된 월, 4자리 연도 숫자

x.strftime("%A %d. %B %Y")

>>>

'Monday 07. March 2022'

x.strftime("%Y-%m-%d")

>>>

'2022-03-07'

x.strftime("%H %M %S")

>>>

'17 57 17'

x.strftime("%A %m %d %H %M %S %A %B")

>>>

'Monday 03 07 17 57 17 Monday March'

x.date() # 날짜 정보만 갖는 클래스 객체 반환

>>>

datetime.date(2022, 3, 7)

x.time() # 시간 정보만 갖는 클래스 객체 반환

>>>

datetime.time(17, 57, 17, 791445)
```

#### datetime 클래스의 여러가지 속성들 호출

```python
x.year, x.month, x.day, x.hour, x.minute, x.second, x.microsecond

>>>

(2022, 3, 7, 17, 57, 17, 791445)
```

#### 문자열을 입력받아서 datetime 클래스로 반환하는 클래스 메서드
- strptime(날짜와 시간정보를 갖는 문자열, 형식문자열)
    - 내가 입력한 date 문자열을 형식문자열의 형태대로 반환 해준다.

```python
new_dt = dt.datetime.strptime("2022-03-07 18:23", "%Y-%m-%d %H:%M")
new_dt

>>>

datetime.datetime(2022, 3, 7, 18, 23)
```

### 연습문제
- strftime 메서드를 사용하여 자신의 생일을 "xxxx년 xx월 xx일 x요일"과 같은 형식으로 출력 해보자

```python
my_birthday = dt.datetime.strptime("1986-03-30", "%Y-%m-%d")
my_birthday

>>>

datetime.datetime(1986, 3, 30, 0, 0)
```

```python
print("{}년 {}월 {}일 {}".format(my_birthday.strftime("%Y"), \
                              my_birthday.strftime("%m"), \
                              my_birthday.strftime("%d"), \
                              my_birthday.strftime("%A")))

>>>

1986년 03월 30일 Sunday
```

### 연습문제
- 자신의 생일을 나타내는 datetime 클래스 객체를 만들고 오늘 자신의 만 나이를 구하라

```python
today = dt.datetime.now()
today

>>>

datetime.datetime(2022, 3, 7, 19, 5, 41, 47628)

# date 형식변환
today = today.strftime("%Y%m%d")
today

>>>

'20220307'

# str을 int로 자료형 변환
today = int(today)
today

>>>

20220307

# 내 생일 객체를 만들고 int로 자료형 변환
bday = dt.datetime.strptime("19860330", "%Y%m%d").strftime("%Y%m%d")
bday = int(bday)

>>>

19860330

# today - bday
round(today - bday, -2) / 10000

>>>

36.0
```

### dateutill 패키지
- dateutill 패키지의 **parse** 함수를 쓰면, 문자열을 자동으로 형식 문자열에 맞춰서 변환해준다.
- 월과 일이 모두 12보다 작은 경우 먼저나오는 숫자를 월, 나중에 나오는 숫자를 일로 판단한다.

```python
from dateutil.parser import parse

parse('1986-03-30')

>>>

datetime.datetime(1986, 3, 30, 0, 0)

parse('Mar 07, 2022 07:11:30 PM')

>>>

datetime.datetime(2022, 3, 7, 19, 11, 30)

parse("5/5/2022")

>>>

datetime.datetime(2022, 5, 5, 0, 0)
```

### 날짜/시간 연산
- 날짜, 시간의 간격을 구할 때는 두 개의 datetime 클래스 객체의 차이를 구한다.
- 이 결과는 `timedlta 클래스` 객체로 반환된다.
- 속성 
    - days : 일수
    - seconds : 초
    - microseconds : 마이크로초
- 메서드
    - total_seconds : 모든 속성을 초단위로 모아서 반환
- 데이트 타임 + 타임델터 연산으로 새로운 datetime을 구할 수 있다.
    - 2022-03-07 + 165일, 3600초 = ?

```python
dt1 = dt.datetime(2022, 3, 7, 22)
dt2 = dt.datetime(2022, 1, 1, 12)
td = dt1 - dt2
td

>>>

datetime.timedelta(days=65, seconds=36000)

td.days

>>>

65

td.seconds

>>>

36000

td.total_seconds()

>>>

5652000.0
```

#### datetime + timedelta
- 현재 날짜 기준으로 x일을 더한 날짜를 계산할 수 있다.
- timedelta() 클래스를 사용

```python
t0 = dt.datetime(2022, 3, 7, 19)
d = dt.timedelta(days=165, seconds=2000)

# 현재 날짜와 165일 2000초를 더해준다.
t0 + d

datetime.datetime(2022, 8, 19, 19, 33, 20)
```

### 연습문제
- 자신의 내년 생일까지 남은 날 수 계산하기
- 자신의 내년 생일까지 남은 시간을 분 단위로 계산하기

```python
t_day = dt.datetime(2022, 3, 7, 19)
next_bday = dt.datetime(2023, 3, 30, 0)

interval = next_bday - t_day
interval

>>>

datetime.timedelta(days=387, seconds=18000)

print("내년 생일까지 남은 일수 : {}일".format(interval.days))
print("내년 생일까지 남은 시간 : {}분".format(interval.seconds / 60))

>>>

내년 생일까지 남은 일수 : 387일
내년 생일까지 남은 시간 : 300.0분
```

### 월단위 계산 : dateutil 패키지의 relativedelta 클래스
- timedelta 클래스는 날짜, 시간, 초 단위로 연산을 할 수 있다.
- relativedelta 클래스는 월 단위의 연산을 해준다.

```python
from dateutil.relativedelta import relativedelta

t_day + relativedelta(months=6)

>>>

datetime.datetime(2022, 9, 7, 19, 0)
```

### 연습문제
- relativedelta 클래스를 사용하여 2000년이 윤년인지 확인하라
- 2000년 2월의 마지막 날로부터 1년 후의 날짜를 계산하라.

#### 2000/01/31 + 1month = ?
- 2000년 1월 31일 + 한달을 계산 했을 때 2월 마지막 날의 날짜를 확인하여 윤년인지 알 수 있다.

```python
# 2000년 1월 31일 날짜 객체 생성
t1 = parse("20000131")
t1

>>>

datetime.datetime(2000, 1, 31, 0, 0)

# 윤년인지 확인하기 위해 t1에 월단위 계산 클래스로 1달을 더해준다.
# 29일이므로 윤년이다.
t2 = t1 + relativedelta(months=1)
t2

>>>

datetime.datetime(2000, 2, 29, 0, 0)

# 일단위 계산 클래스  timedelta(days=365) 를 사용하여 1년 후의 날짜를 계산할 수 있다.
# 윤년의 다음해의 2월은 28일이 마지막 날짜이다.
t2_365 = t2 + dt.timedelta(days=365)
t2_365

>>>

datetime.datetime(2001, 2, 28, 0, 0)
```
